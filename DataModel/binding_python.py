# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_statistics_ietf_interfaces__interfaces_interface_statistics(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-interfaces - based on the path /interfaces/interface/statistics. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A collection of interface-related statistics objects.
  """
  __slots__ = ('_path_helper', '_extmethods', '__discontinuity_time','__in_octets','__in_unicast_pkts','__in_broadcast_pkts','__in_multicast_pkts','__in_discards','__in_errors','__in_unknown_protos','__out_octets','__out_unicast_pkts','__out_broadcast_pkts','__out_multicast_pkts','__out_discards','__out_errors',)

  _yang_name = 'statistics'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__discontinuity_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="discontinuity-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:date-and-time', is_config=False)
    self.__in_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    self.__in_discards = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    self.__out_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    self.__out_broadcast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    self.__in_broadcast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    self.__in_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    self.__out_unicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    self.__in_multicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    self.__in_unicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    self.__in_unknown_protos = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-unknown-protos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    self.__out_discards = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    self.__out_multicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    self.__out_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'interfaces', u'interface', u'statistics']

  def _get_discontinuity_time(self):
    """
    Getter method for discontinuity_time, mapped from YANG variable /interfaces/interface/statistics/discontinuity_time (yang:date-and-time)

    YANG Description: The time on the most recent occasion at which any one or
more of this interface's counters suffered a
discontinuity.  If no such discontinuities have occurred
since the last re-initialization of the local management
subsystem, then this node contains the time the local
management subsystem re-initialized itself.
    """
    return self.__discontinuity_time
      
  def _set_discontinuity_time(self, v, load=False):
    """
    Setter method for discontinuity_time, mapped from YANG variable /interfaces/interface/statistics/discontinuity_time (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_discontinuity_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_discontinuity_time() directly.

    YANG Description: The time on the most recent occasion at which any one or
more of this interface's counters suffered a
discontinuity.  If no such discontinuities have occurred
since the last re-initialization of the local management
subsystem, then this node contains the time the local
management subsystem re-initialized itself.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="discontinuity-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """discontinuity_time must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="discontinuity-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__discontinuity_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_discontinuity_time(self):
    self.__discontinuity_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="discontinuity-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:date-and-time', is_config=False)


  def _get_in_octets(self):
    """
    Getter method for in_octets, mapped from YANG variable /interfaces/interface/statistics/in_octets (yang:counter64)

    YANG Description: The total number of octets received on the interface,
including framing characters.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__in_octets
      
  def _set_in_octets(self, v, load=False):
    """
    Setter method for in_octets, mapped from YANG variable /interfaces/interface/statistics/in_octets (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_octets() directly.

    YANG Description: The total number of octets received on the interface,
including framing characters.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_octets must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)""",
        })

    self.__in_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_octets(self):
    self.__in_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)


  def _get_in_unicast_pkts(self):
    """
    Getter method for in_unicast_pkts, mapped from YANG variable /interfaces/interface/statistics/in_unicast_pkts (yang:counter64)

    YANG Description: The number of packets, delivered by this sub-layer to a
higher (sub-)layer, that were not addressed to a
multicast or broadcast address at this sub-layer.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__in_unicast_pkts
      
  def _set_in_unicast_pkts(self, v, load=False):
    """
    Setter method for in_unicast_pkts, mapped from YANG variable /interfaces/interface/statistics/in_unicast_pkts (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_unicast_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_unicast_pkts() directly.

    YANG Description: The number of packets, delivered by this sub-layer to a
higher (sub-)layer, that were not addressed to a
multicast or broadcast address at this sub-layer.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_unicast_pkts must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)""",
        })

    self.__in_unicast_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_unicast_pkts(self):
    self.__in_unicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)


  def _get_in_broadcast_pkts(self):
    """
    Getter method for in_broadcast_pkts, mapped from YANG variable /interfaces/interface/statistics/in_broadcast_pkts (yang:counter64)

    YANG Description: The number of packets, delivered by this sub-layer to a
higher (sub-)layer, that were addressed to a broadcast
address at this sub-layer.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__in_broadcast_pkts
      
  def _set_in_broadcast_pkts(self, v, load=False):
    """
    Setter method for in_broadcast_pkts, mapped from YANG variable /interfaces/interface/statistics/in_broadcast_pkts (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_broadcast_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_broadcast_pkts() directly.

    YANG Description: The number of packets, delivered by this sub-layer to a
higher (sub-)layer, that were addressed to a broadcast
address at this sub-layer.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_broadcast_pkts must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)""",
        })

    self.__in_broadcast_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_broadcast_pkts(self):
    self.__in_broadcast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)


  def _get_in_multicast_pkts(self):
    """
    Getter method for in_multicast_pkts, mapped from YANG variable /interfaces/interface/statistics/in_multicast_pkts (yang:counter64)

    YANG Description: The number of packets, delivered by this sub-layer to a
higher (sub-)layer, that were addressed to a multicast
address at this sub-layer.  For a MAC-layer protocol,
this includes both Group and Functional addresses.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__in_multicast_pkts
      
  def _set_in_multicast_pkts(self, v, load=False):
    """
    Setter method for in_multicast_pkts, mapped from YANG variable /interfaces/interface/statistics/in_multicast_pkts (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_multicast_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_multicast_pkts() directly.

    YANG Description: The number of packets, delivered by this sub-layer to a
higher (sub-)layer, that were addressed to a multicast
address at this sub-layer.  For a MAC-layer protocol,
this includes both Group and Functional addresses.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_multicast_pkts must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)""",
        })

    self.__in_multicast_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_multicast_pkts(self):
    self.__in_multicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)


  def _get_in_discards(self):
    """
    Getter method for in_discards, mapped from YANG variable /interfaces/interface/statistics/in_discards (yang:counter32)

    YANG Description: The number of inbound packets that were chosen to be
discarded even though no errors had been detected to
prevent their being deliverable to a higher-layer
protocol.  One possible reason for discarding such a
packet could be to free up buffer space.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__in_discards
      
  def _set_in_discards(self, v, load=False):
    """
    Setter method for in_discards, mapped from YANG variable /interfaces/interface/statistics/in_discards (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_discards is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_discards() directly.

    YANG Description: The number of inbound packets that were chosen to be
discarded even though no errors had been detected to
prevent their being deliverable to a higher-layer
protocol.  One possible reason for discarding such a
packet could be to free up buffer space.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_discards must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)""",
        })

    self.__in_discards = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_discards(self):
    self.__in_discards = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)


  def _get_in_errors(self):
    """
    Getter method for in_errors, mapped from YANG variable /interfaces/interface/statistics/in_errors (yang:counter32)

    YANG Description: For packet-oriented interfaces, the number of inbound
packets that contained errors preventing them from being
deliverable to a higher-layer protocol.  For character-
oriented or fixed-length interfaces, the number of
inbound transmission units that contained errors
preventing them from being deliverable to a higher-layer
protocol.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__in_errors
      
  def _set_in_errors(self, v, load=False):
    """
    Setter method for in_errors, mapped from YANG variable /interfaces/interface/statistics/in_errors (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_errors() directly.

    YANG Description: For packet-oriented interfaces, the number of inbound
packets that contained errors preventing them from being
deliverable to a higher-layer protocol.  For character-
oriented or fixed-length interfaces, the number of
inbound transmission units that contained errors
preventing them from being deliverable to a higher-layer
protocol.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_errors must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)""",
        })

    self.__in_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_errors(self):
    self.__in_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)


  def _get_in_unknown_protos(self):
    """
    Getter method for in_unknown_protos, mapped from YANG variable /interfaces/interface/statistics/in_unknown_protos (yang:counter32)

    YANG Description: For packet-oriented interfaces, the number of packets
received via the interface that were discarded because
of an unknown or unsupported protocol.  For
character-oriented or fixed-length interfaces that
support protocol multiplexing, the number of
transmission units received via the interface that were
discarded because of an unknown or unsupported protocol.
For any interface that does not support protocol
multiplexing, this counter is not present.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__in_unknown_protos
      
  def _set_in_unknown_protos(self, v, load=False):
    """
    Setter method for in_unknown_protos, mapped from YANG variable /interfaces/interface/statistics/in_unknown_protos (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_unknown_protos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_unknown_protos() directly.

    YANG Description: For packet-oriented interfaces, the number of packets
received via the interface that were discarded because
of an unknown or unsupported protocol.  For
character-oriented or fixed-length interfaces that
support protocol multiplexing, the number of
transmission units received via the interface that were
discarded because of an unknown or unsupported protocol.
For any interface that does not support protocol
multiplexing, this counter is not present.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-unknown-protos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_unknown_protos must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-unknown-protos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)""",
        })

    self.__in_unknown_protos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_unknown_protos(self):
    self.__in_unknown_protos = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-unknown-protos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)


  def _get_out_octets(self):
    """
    Getter method for out_octets, mapped from YANG variable /interfaces/interface/statistics/out_octets (yang:counter64)

    YANG Description: The total number of octets transmitted out of the
interface, including framing characters.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__out_octets
      
  def _set_out_octets(self, v, load=False):
    """
    Setter method for out_octets, mapped from YANG variable /interfaces/interface/statistics/out_octets (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_octets() directly.

    YANG Description: The total number of octets transmitted out of the
interface, including framing characters.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_octets must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)""",
        })

    self.__out_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_octets(self):
    self.__out_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)


  def _get_out_unicast_pkts(self):
    """
    Getter method for out_unicast_pkts, mapped from YANG variable /interfaces/interface/statistics/out_unicast_pkts (yang:counter64)

    YANG Description: The total number of packets that higher-level protocols
requested be transmitted and that were not addressed
to a multicast or broadcast address at this sub-layer,
including those that were discarded or not sent.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__out_unicast_pkts
      
  def _set_out_unicast_pkts(self, v, load=False):
    """
    Setter method for out_unicast_pkts, mapped from YANG variable /interfaces/interface/statistics/out_unicast_pkts (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_unicast_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_unicast_pkts() directly.

    YANG Description: The total number of packets that higher-level protocols
requested be transmitted and that were not addressed
to a multicast or broadcast address at this sub-layer,
including those that were discarded or not sent.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_unicast_pkts must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)""",
        })

    self.__out_unicast_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_unicast_pkts(self):
    self.__out_unicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)


  def _get_out_broadcast_pkts(self):
    """
    Getter method for out_broadcast_pkts, mapped from YANG variable /interfaces/interface/statistics/out_broadcast_pkts (yang:counter64)

    YANG Description: The total number of packets that higher-level protocols
requested be transmitted and that were addressed to a
broadcast address at this sub-layer, including those
that were discarded or not sent.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__out_broadcast_pkts
      
  def _set_out_broadcast_pkts(self, v, load=False):
    """
    Setter method for out_broadcast_pkts, mapped from YANG variable /interfaces/interface/statistics/out_broadcast_pkts (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_broadcast_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_broadcast_pkts() directly.

    YANG Description: The total number of packets that higher-level protocols
requested be transmitted and that were addressed to a
broadcast address at this sub-layer, including those
that were discarded or not sent.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_broadcast_pkts must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)""",
        })

    self.__out_broadcast_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_broadcast_pkts(self):
    self.__out_broadcast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)


  def _get_out_multicast_pkts(self):
    """
    Getter method for out_multicast_pkts, mapped from YANG variable /interfaces/interface/statistics/out_multicast_pkts (yang:counter64)

    YANG Description: The total number of packets that higher-level protocols
requested be transmitted and that were addressed to a
multicast address at this sub-layer, including those
that were discarded or not sent.  For a MAC-layer
protocol, this includes both Group and Functional
addresses.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__out_multicast_pkts
      
  def _set_out_multicast_pkts(self, v, load=False):
    """
    Setter method for out_multicast_pkts, mapped from YANG variable /interfaces/interface/statistics/out_multicast_pkts (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_multicast_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_multicast_pkts() directly.

    YANG Description: The total number of packets that higher-level protocols
requested be transmitted and that were addressed to a
multicast address at this sub-layer, including those
that were discarded or not sent.  For a MAC-layer
protocol, this includes both Group and Functional
addresses.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_multicast_pkts must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)""",
        })

    self.__out_multicast_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_multicast_pkts(self):
    self.__out_multicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)


  def _get_out_discards(self):
    """
    Getter method for out_discards, mapped from YANG variable /interfaces/interface/statistics/out_discards (yang:counter32)

    YANG Description: The number of outbound packets that were chosen to be
discarded even though no errors had been detected to
prevent their being transmitted.  One possible reason
for discarding such a packet could be to free up buffer
space.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__out_discards
      
  def _set_out_discards(self, v, load=False):
    """
    Setter method for out_discards, mapped from YANG variable /interfaces/interface/statistics/out_discards (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_discards is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_discards() directly.

    YANG Description: The number of outbound packets that were chosen to be
discarded even though no errors had been detected to
prevent their being transmitted.  One possible reason
for discarding such a packet could be to free up buffer
space.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_discards must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)""",
        })

    self.__out_discards = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_discards(self):
    self.__out_discards = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)


  def _get_out_errors(self):
    """
    Getter method for out_errors, mapped from YANG variable /interfaces/interface/statistics/out_errors (yang:counter32)

    YANG Description: For packet-oriented interfaces, the number of outbound
packets that could not be transmitted because of errors.
For character-oriented or fixed-length interfaces, the
number of outbound transmission units that could not be
transmitted because of errors.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__out_errors
      
  def _set_out_errors(self, v, load=False):
    """
    Setter method for out_errors, mapped from YANG variable /interfaces/interface/statistics/out_errors (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_errors() directly.

    YANG Description: For packet-oriented interfaces, the number of outbound
packets that could not be transmitted because of errors.
For character-oriented or fixed-length interfaces, the
number of outbound transmission units that could not be
transmitted because of errors.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_errors must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)""",
        })

    self.__out_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_errors(self):
    self.__out_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)

  discontinuity_time = __builtin__.property(_get_discontinuity_time)
  in_octets = __builtin__.property(_get_in_octets)
  in_unicast_pkts = __builtin__.property(_get_in_unicast_pkts)
  in_broadcast_pkts = __builtin__.property(_get_in_broadcast_pkts)
  in_multicast_pkts = __builtin__.property(_get_in_multicast_pkts)
  in_discards = __builtin__.property(_get_in_discards)
  in_errors = __builtin__.property(_get_in_errors)
  in_unknown_protos = __builtin__.property(_get_in_unknown_protos)
  out_octets = __builtin__.property(_get_out_octets)
  out_unicast_pkts = __builtin__.property(_get_out_unicast_pkts)
  out_broadcast_pkts = __builtin__.property(_get_out_broadcast_pkts)
  out_multicast_pkts = __builtin__.property(_get_out_multicast_pkts)
  out_discards = __builtin__.property(_get_out_discards)
  out_errors = __builtin__.property(_get_out_errors)


  _pyangbind_elements = OrderedDict([('discontinuity_time', discontinuity_time), ('in_octets', in_octets), ('in_unicast_pkts', in_unicast_pkts), ('in_broadcast_pkts', in_broadcast_pkts), ('in_multicast_pkts', in_multicast_pkts), ('in_discards', in_discards), ('in_errors', in_errors), ('in_unknown_protos', in_unknown_protos), ('out_octets', out_octets), ('out_unicast_pkts', out_unicast_pkts), ('out_broadcast_pkts', out_broadcast_pkts), ('out_multicast_pkts', out_multicast_pkts), ('out_discards', out_discards), ('out_errors', out_errors), ])


class yc_interface_ietf_interfaces__interfaces_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-interfaces - based on the path /interfaces/interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of interfaces on the device.

The status of an interface is available in this list in the
operational state.  If the configuration of a
system-controlled interface cannot be used by the system
(e.g., the interface hardware present does not match the
interface type), then the configuration is not applied to
the system-controlled interface shown in the operational
state.  If the configuration of a user-controlled interface
cannot be used by the system, the configured interface is
not instantiated in the operational state.

System-controlled interfaces created by the system are
always present in this list in the operational state,
whether or not they are configured.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__description','__type','__enabled','__link_up_down_trap_enable','__admin_status','__oper_status','__last_change','__if_index','__phys_address','__higher_layer_if','__lower_layer_if','__speed','__statistics',)

  _yang_name = 'interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__statistics = YANGDynClass(base=yc_statistics_ietf_interfaces__interfaces_interface_statistics, is_container='container', yang_name="statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=True)
    self.__if_index = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={u'range': [u'1..2147483647']}), is_leaf=True, yang_name="if-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='int32', is_config=False)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='string', is_config=True)
    self.__higher_layer_if = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="higher-layer-if", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='interface-ref', is_config=False)
    self.__last_change = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-change", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:date-and-time', is_config=False)
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='boolean', is_config=True)
    self.__oper_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'dormant': {u'value': 5}, u'lower-layer-down': {u'value': 7}, u'unknown': {u'value': 4}, u'testing': {u'value': 3}, u'up': {u'value': 1}, u'down': {u'value': 2}, u'not-present': {u'value': 6}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=False)
    self.__link_up_down_trap_enable = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'disabled': {u'value': 2}, u'enabled': {u'value': 1}},), is_leaf=True, yang_name="link-up-down-trap-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=True)
    self.__admin_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'down': {u'value': 2}, u'testing': {u'value': 3}, u'up': {u'value': 1}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=False)
    self.__phys_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="phys-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:phys-address', is_config=False)
    self.__lower_layer_if = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="lower-layer-if", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='interface-ref', is_config=False)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='identityref', is_config=True)
    self.__speed = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:gauge64', is_config=False)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'interfaces', u'interface']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /interfaces/interface/name (string)

    YANG Description: The name of the interface.

A device MAY restrict the allowed values for this leaf,
possibly depending on the type of the interface.
For system-controlled interfaces, this leaf is the
device-specific name of the interface.

If a client tries to create configuration for a
system-controlled interface that is not present in the
operational state, the server MAY reject the request if
the implementation does not support pre-provisioning of
interfaces or if the name refers to an interface that can
never exist in the system.  A Network Configuration
Protocol (NETCONF) server MUST reply with an rpc-error
with the error-tag 'invalid-value' in this case.

If the device supports pre-provisioning of interface
configuration, the 'pre-provisioning' feature is
advertised.

If the device allows arbitrarily named user-controlled
interfaces, the 'arbitrary-names' feature is advertised.

When a configured user-controlled interface is created by
the system, it is instantiated with the same name in the
operational state.

A server implementation MAY map this leaf to the ifName
MIB object.  Such an implementation needs to use some
mechanism to handle the differences in size and characters
allowed between this leaf and ifName.  The definition of
such a mechanism is outside the scope of this document.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /interfaces/interface/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the interface.

A device MAY restrict the allowed values for this leaf,
possibly depending on the type of the interface.
For system-controlled interfaces, this leaf is the
device-specific name of the interface.

If a client tries to create configuration for a
system-controlled interface that is not present in the
operational state, the server MAY reject the request if
the implementation does not support pre-provisioning of
interfaces or if the name refers to an interface that can
never exist in the system.  A Network Configuration
Protocol (NETCONF) server MUST reply with an rpc-error
with the error-tag 'invalid-value' in this case.

If the device supports pre-provisioning of interface
configuration, the 'pre-provisioning' feature is
advertised.

If the device allows arbitrarily named user-controlled
interfaces, the 'arbitrary-names' feature is advertised.

When a configured user-controlled interface is created by
the system, it is instantiated with the same name in the
operational state.

A server implementation MAY map this leaf to the ifName
MIB object.  Such an implementation needs to use some
mechanism to handle the differences in size and characters
allowed between this leaf and ifName.  The definition of
such a mechanism is outside the scope of this document.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /interfaces/interface/description (string)

    YANG Description: A textual description of the interface.

A server implementation MAY map this leaf to the ifAlias
MIB object.  Such an implementation needs to use some
mechanism to handle the differences in size and characters
allowed between this leaf and ifAlias.  The definition of
such a mechanism is outside the scope of this document.

Since ifAlias is defined to be stored in non-volatile
storage, the MIB implementation MUST map ifAlias to the
value of 'description' in the persistently stored
configuration.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /interfaces/interface/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: A textual description of the interface.

A server implementation MAY map this leaf to the ifAlias
MIB object.  Such an implementation needs to use some
mechanism to handle the differences in size and characters
allowed between this leaf and ifAlias.  The definition of
such a mechanism is outside the scope of this document.

Since ifAlias is defined to be stored in non-volatile
storage, the MIB implementation MUST map ifAlias to the
value of 'description' in the persistently stored
configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /interfaces/interface/type (identityref)

    YANG Description: The type of the interface.

When an interface entry is created, a server MAY
initialize the type leaf with a valid value, e.g., if it
is possible to derive the type from the name of the
interface.

If a client tries to set the type of an interface to a
value that can never be used by the system, e.g., if the
type is not supported or if the type does not match the
name of the interface, the server MUST reject the request.
A NETCONF server MUST reply with an rpc-error with the
error-tag 'invalid-value' in this case.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /interfaces/interface/type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: The type of the interface.

When an interface entry is created, a server MAY
initialize the type leaf with a valid value, e.g., if it
is possible to derive the type from the name of the
interface.

If a client tries to set the type of an interface to a
value that can never be used by the system, e.g., if the
type is not supported or if the type does not match the
name of the interface, the server MUST reject the request.
A NETCONF server MUST reply with an rpc-error with the
error-tag 'invalid-value' in this case.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with identityref""",
          'defined-type': "ietf-interfaces:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='identityref', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='identityref', is_config=True)


  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /interfaces/interface/enabled (boolean)

    YANG Description: This leaf contains the configured, desired state of the
interface.

Systems that implement the IF-MIB use the value of this
leaf in the intended configuration to set
IF-MIB.ifAdminStatus to 'up' or 'down' after an ifEntry
has been initialized, as described in RFC 2863.

Changes in this leaf in the intended configuration are
reflected in ifAdminStatus.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /interfaces/interface/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: This leaf contains the configured, desired state of the
interface.

Systems that implement the IF-MIB use the value of this
leaf in the intended configuration to set
IF-MIB.ifAdminStatus to 'up' or 'down' after an ifEntry
has been initialized, as described in RFC 2863.

Changes in this leaf in the intended configuration are
reflected in ifAdminStatus.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='boolean', is_config=True)


  def _get_link_up_down_trap_enable(self):
    """
    Getter method for link_up_down_trap_enable, mapped from YANG variable /interfaces/interface/link_up_down_trap_enable (enumeration)

    YANG Description: Controls whether linkUp/linkDown SNMP notifications
should be generated for this interface.

If this node is not configured, the value 'enabled' is
operationally used by the server for interfaces that do
not operate on top of any other interface (i.e., there are
no 'lower-layer-if' entries), and 'disabled' otherwise.
    """
    return self.__link_up_down_trap_enable
      
  def _set_link_up_down_trap_enable(self, v, load=False):
    """
    Setter method for link_up_down_trap_enable, mapped from YANG variable /interfaces/interface/link_up_down_trap_enable (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_up_down_trap_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_up_down_trap_enable() directly.

    YANG Description: Controls whether linkUp/linkDown SNMP notifications
should be generated for this interface.

If this node is not configured, the value 'enabled' is
operationally used by the server for interfaces that do
not operate on top of any other interface (i.e., there are
no 'lower-layer-if' entries), and 'disabled' otherwise.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'disabled': {u'value': 2}, u'enabled': {u'value': 1}},), is_leaf=True, yang_name="link-up-down-trap-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_up_down_trap_enable must be of a type compatible with enumeration""",
          'defined-type': "ietf-interfaces:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'disabled': {u'value': 2}, u'enabled': {u'value': 1}},), is_leaf=True, yang_name="link-up-down-trap-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=True)""",
        })

    self.__link_up_down_trap_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_up_down_trap_enable(self):
    self.__link_up_down_trap_enable = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'disabled': {u'value': 2}, u'enabled': {u'value': 1}},), is_leaf=True, yang_name="link-up-down-trap-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=True)


  def _get_admin_status(self):
    """
    Getter method for admin_status, mapped from YANG variable /interfaces/interface/admin_status (enumeration)

    YANG Description: The desired state of the interface.

This leaf has the same read semantics as ifAdminStatus.
    """
    return self.__admin_status
      
  def _set_admin_status(self, v, load=False):
    """
    Setter method for admin_status, mapped from YANG variable /interfaces/interface/admin_status (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_status() directly.

    YANG Description: The desired state of the interface.

This leaf has the same read semantics as ifAdminStatus.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'down': {u'value': 2}, u'testing': {u'value': 3}, u'up': {u'value': 1}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_status must be of a type compatible with enumeration""",
          'defined-type': "ietf-interfaces:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'down': {u'value': 2}, u'testing': {u'value': 3}, u'up': {u'value': 1}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=False)""",
        })

    self.__admin_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_status(self):
    self.__admin_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'down': {u'value': 2}, u'testing': {u'value': 3}, u'up': {u'value': 1}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=False)


  def _get_oper_status(self):
    """
    Getter method for oper_status, mapped from YANG variable /interfaces/interface/oper_status (enumeration)

    YANG Description: The current operational state of the interface.

This leaf has the same semantics as ifOperStatus.
    """
    return self.__oper_status
      
  def _set_oper_status(self, v, load=False):
    """
    Setter method for oper_status, mapped from YANG variable /interfaces/interface/oper_status (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oper_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oper_status() directly.

    YANG Description: The current operational state of the interface.

This leaf has the same semantics as ifOperStatus.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'dormant': {u'value': 5}, u'lower-layer-down': {u'value': 7}, u'unknown': {u'value': 4}, u'testing': {u'value': 3}, u'up': {u'value': 1}, u'down': {u'value': 2}, u'not-present': {u'value': 6}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oper_status must be of a type compatible with enumeration""",
          'defined-type': "ietf-interfaces:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'dormant': {u'value': 5}, u'lower-layer-down': {u'value': 7}, u'unknown': {u'value': 4}, u'testing': {u'value': 3}, u'up': {u'value': 1}, u'down': {u'value': 2}, u'not-present': {u'value': 6}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=False)""",
        })

    self.__oper_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oper_status(self):
    self.__oper_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'dormant': {u'value': 5}, u'lower-layer-down': {u'value': 7}, u'unknown': {u'value': 4}, u'testing': {u'value': 3}, u'up': {u'value': 1}, u'down': {u'value': 2}, u'not-present': {u'value': 6}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=False)


  def _get_last_change(self):
    """
    Getter method for last_change, mapped from YANG variable /interfaces/interface/last_change (yang:date-and-time)

    YANG Description: The time the interface entered its current operational
state.  If the current state was entered prior to the
last re-initialization of the local network management
subsystem, then this node is not present.
    """
    return self.__last_change
      
  def _set_last_change(self, v, load=False):
    """
    Setter method for last_change, mapped from YANG variable /interfaces/interface/last_change (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_change is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_change() directly.

    YANG Description: The time the interface entered its current operational
state.  If the current state was entered prior to the
last re-initialization of the local network management
subsystem, then this node is not present.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-change", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_change must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-change", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__last_change = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_change(self):
    self.__last_change = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-change", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:date-and-time', is_config=False)


  def _get_if_index(self):
    """
    Getter method for if_index, mapped from YANG variable /interfaces/interface/if_index (int32)

    YANG Description: The ifIndex value for the ifEntry represented by this
interface.
    """
    return self.__if_index
      
  def _set_if_index(self, v, load=False):
    """
    Setter method for if_index, mapped from YANG variable /interfaces/interface/if_index (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_if_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_if_index() directly.

    YANG Description: The ifIndex value for the ifEntry represented by this
interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={u'range': [u'1..2147483647']}), is_leaf=True, yang_name="if-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """if_index must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={u'range': [u'1..2147483647']}), is_leaf=True, yang_name="if-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='int32', is_config=False)""",
        })

    self.__if_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_if_index(self):
    self.__if_index = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={u'range': [u'1..2147483647']}), is_leaf=True, yang_name="if-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='int32', is_config=False)


  def _get_phys_address(self):
    """
    Getter method for phys_address, mapped from YANG variable /interfaces/interface/phys_address (yang:phys-address)

    YANG Description: The interface's address at its protocol sub-layer.  For
example, for an 802.x interface, this object normally
contains a Media Access Control (MAC) address.  The
interface's media-specific modules must define the bit
and byte ordering and the format of the value of this
object.  For interfaces that do not have such an address
(e.g., a serial line), this node is not present.
    """
    return self.__phys_address
      
  def _set_phys_address(self, v, load=False):
    """
    Setter method for phys_address, mapped from YANG variable /interfaces/interface/phys_address (yang:phys-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_phys_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_phys_address() directly.

    YANG Description: The interface's address at its protocol sub-layer.  For
example, for an 802.x interface, this object normally
contains a Media Access Control (MAC) address.  The
interface's media-specific modules must define the bit
and byte ordering and the format of the value of this
object.  For interfaces that do not have such an address
(e.g., a serial line), this node is not present.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="phys-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:phys-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """phys_address must be of a type compatible with yang:phys-address""",
          'defined-type': "yang:phys-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="phys-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:phys-address', is_config=False)""",
        })

    self.__phys_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_phys_address(self):
    self.__phys_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="phys-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:phys-address', is_config=False)


  def _get_higher_layer_if(self):
    """
    Getter method for higher_layer_if, mapped from YANG variable /interfaces/interface/higher_layer_if (interface-ref)

    YANG Description: A list of references to interfaces layered on top of this
interface.
    """
    return self.__higher_layer_if
      
  def _set_higher_layer_if(self, v, load=False):
    """
    Setter method for higher_layer_if, mapped from YANG variable /interfaces/interface/higher_layer_if (interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_higher_layer_if is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_higher_layer_if() directly.

    YANG Description: A list of references to interfaces layered on top of this
interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="higher-layer-if", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """higher_layer_if must be of a type compatible with interface-ref""",
          'defined-type': "ietf-interfaces:interface-ref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="higher-layer-if", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='interface-ref', is_config=False)""",
        })

    self.__higher_layer_if = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_higher_layer_if(self):
    self.__higher_layer_if = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="higher-layer-if", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='interface-ref', is_config=False)


  def _get_lower_layer_if(self):
    """
    Getter method for lower_layer_if, mapped from YANG variable /interfaces/interface/lower_layer_if (interface-ref)

    YANG Description: A list of references to interfaces layered underneath this
interface.
    """
    return self.__lower_layer_if
      
  def _set_lower_layer_if(self, v, load=False):
    """
    Setter method for lower_layer_if, mapped from YANG variable /interfaces/interface/lower_layer_if (interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lower_layer_if is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lower_layer_if() directly.

    YANG Description: A list of references to interfaces layered underneath this
interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="lower-layer-if", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lower_layer_if must be of a type compatible with interface-ref""",
          'defined-type': "ietf-interfaces:interface-ref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="lower-layer-if", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='interface-ref', is_config=False)""",
        })

    self.__lower_layer_if = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lower_layer_if(self):
    self.__lower_layer_if = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="lower-layer-if", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='interface-ref', is_config=False)


  def _get_speed(self):
    """
    Getter method for speed, mapped from YANG variable /interfaces/interface/speed (yang:gauge64)

    YANG Description: An estimate of the interface's current bandwidth in bits
per second.  For interfaces that do not vary in
bandwidth or for those where no accurate estimation can
be made, this node should contain the nominal bandwidth.
For interfaces that have no concept of bandwidth, this
node is not present.
    """
    return self.__speed
      
  def _set_speed(self, v, load=False):
    """
    Setter method for speed, mapped from YANG variable /interfaces/interface/speed (yang:gauge64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_speed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_speed() directly.

    YANG Description: An estimate of the interface's current bandwidth in bits
per second.  For interfaces that do not vary in
bandwidth or for those where no accurate estimation can
be made, this node should contain the nominal bandwidth.
For interfaces that have no concept of bandwidth, this
node is not present.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:gauge64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """speed must be of a type compatible with yang:gauge64""",
          'defined-type': "yang:gauge64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:gauge64', is_config=False)""",
        })

    self.__speed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_speed(self):
    self.__speed = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:gauge64', is_config=False)


  def _get_statistics(self):
    """
    Getter method for statistics, mapped from YANG variable /interfaces/interface/statistics (container)

    YANG Description: A collection of interface-related statistics objects.
    """
    return self.__statistics
      
  def _set_statistics(self, v, load=False):
    """
    Setter method for statistics, mapped from YANG variable /interfaces/interface/statistics (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_statistics is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_statistics() directly.

    YANG Description: A collection of interface-related statistics objects.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_statistics_ietf_interfaces__interfaces_interface_statistics, is_container='container', yang_name="statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """statistics must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_statistics_ietf_interfaces__interfaces_interface_statistics, is_container='container', yang_name="statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=True)""",
        })

    self.__statistics = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_statistics(self):
    self.__statistics = YANGDynClass(base=yc_statistics_ietf_interfaces__interfaces_interface_statistics, is_container='container', yang_name="statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  description = __builtin__.property(_get_description, _set_description)
  type = __builtin__.property(_get_type, _set_type)
  enabled = __builtin__.property(_get_enabled, _set_enabled)
  link_up_down_trap_enable = __builtin__.property(_get_link_up_down_trap_enable, _set_link_up_down_trap_enable)
  admin_status = __builtin__.property(_get_admin_status)
  oper_status = __builtin__.property(_get_oper_status)
  last_change = __builtin__.property(_get_last_change)
  if_index = __builtin__.property(_get_if_index)
  phys_address = __builtin__.property(_get_phys_address)
  higher_layer_if = __builtin__.property(_get_higher_layer_if)
  lower_layer_if = __builtin__.property(_get_lower_layer_if)
  speed = __builtin__.property(_get_speed)
  statistics = __builtin__.property(_get_statistics, _set_statistics)


  _pyangbind_elements = OrderedDict([('name', name), ('description', description), ('type', type), ('enabled', enabled), ('link_up_down_trap_enable', link_up_down_trap_enable), ('admin_status', admin_status), ('oper_status', oper_status), ('last_change', last_change), ('if_index', if_index), ('phys_address', phys_address), ('higher_layer_if', higher_layer_if), ('lower_layer_if', lower_layer_if), ('speed', speed), ('statistics', statistics), ])


class yc_interfaces_ietf_interfaces__interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-interfaces - based on the path /interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Interface parameters.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface',)

  _yang_name = 'interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(base=YANGListType("name",yc_interface_ietf_interfaces__interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'interfaces']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /interfaces/interface (list)

    YANG Description: The list of interfaces on the device.

The status of an interface is available in this list in the
operational state.  If the configuration of a
system-controlled interface cannot be used by the system
(e.g., the interface hardware present does not match the
interface type), then the configuration is not applied to
the system-controlled interface shown in the operational
state.  If the configuration of a user-controlled interface
cannot be used by the system, the configured interface is
not instantiated in the operational state.

System-controlled interfaces created by the system are
always present in this list in the operational state,
whether or not they are configured.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /interfaces/interface (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: The list of interfaces on the device.

The status of an interface is available in this list in the
operational state.  If the configuration of a
system-controlled interface cannot be used by the system
(e.g., the interface hardware present does not match the
interface type), then the configuration is not applied to
the system-controlled interface shown in the operational
state.  If the configuration of a user-controlled interface
cannot be used by the system, the configured interface is
not instantiated in the operational state.

System-controlled interfaces created by the system are
always present in this list in the operational state,
whether or not they are configured.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_interface_ietf_interfaces__interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_interface_ietf_interfaces__interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='list', is_config=True)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=YANGListType("name",yc_interface_ietf_interfaces__interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='list', is_config=True)

  interface = __builtin__.property(_get_interface, _set_interface)


  _pyangbind_elements = OrderedDict([('interface', interface), ])


class yc_statistics_ietf_interfaces__interfaces_state_interface_statistics(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-interfaces - based on the path /interfaces-state/interface/statistics. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A collection of interface-related statistics objects.
  """
  __slots__ = ('_path_helper', '_extmethods', '__discontinuity_time','__in_octets','__in_unicast_pkts','__in_broadcast_pkts','__in_multicast_pkts','__in_discards','__in_errors','__in_unknown_protos','__out_octets','__out_unicast_pkts','__out_broadcast_pkts','__out_multicast_pkts','__out_discards','__out_errors',)

  _yang_name = 'statistics'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__discontinuity_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="discontinuity-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:date-and-time', is_config=False)
    self.__in_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    self.__in_discards = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    self.__out_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    self.__out_broadcast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    self.__in_broadcast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    self.__in_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    self.__out_unicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    self.__in_multicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    self.__in_unicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    self.__in_unknown_protos = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-unknown-protos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    self.__out_discards = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    self.__out_multicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    self.__out_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'interfaces-state', u'interface', u'statistics']

  def _get_discontinuity_time(self):
    """
    Getter method for discontinuity_time, mapped from YANG variable /interfaces_state/interface/statistics/discontinuity_time (yang:date-and-time)

    YANG Description: The time on the most recent occasion at which any one or
more of this interface's counters suffered a
discontinuity.  If no such discontinuities have occurred
since the last re-initialization of the local management
subsystem, then this node contains the time the local
management subsystem re-initialized itself.
    """
    return self.__discontinuity_time
      
  def _set_discontinuity_time(self, v, load=False):
    """
    Setter method for discontinuity_time, mapped from YANG variable /interfaces_state/interface/statistics/discontinuity_time (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_discontinuity_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_discontinuity_time() directly.

    YANG Description: The time on the most recent occasion at which any one or
more of this interface's counters suffered a
discontinuity.  If no such discontinuities have occurred
since the last re-initialization of the local management
subsystem, then this node contains the time the local
management subsystem re-initialized itself.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="discontinuity-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """discontinuity_time must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="discontinuity-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__discontinuity_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_discontinuity_time(self):
    self.__discontinuity_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="discontinuity-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:date-and-time', is_config=False)


  def _get_in_octets(self):
    """
    Getter method for in_octets, mapped from YANG variable /interfaces_state/interface/statistics/in_octets (yang:counter64)

    YANG Description: The total number of octets received on the interface,
including framing characters.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__in_octets
      
  def _set_in_octets(self, v, load=False):
    """
    Setter method for in_octets, mapped from YANG variable /interfaces_state/interface/statistics/in_octets (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_octets() directly.

    YANG Description: The total number of octets received on the interface,
including framing characters.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_octets must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)""",
        })

    self.__in_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_octets(self):
    self.__in_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)


  def _get_in_unicast_pkts(self):
    """
    Getter method for in_unicast_pkts, mapped from YANG variable /interfaces_state/interface/statistics/in_unicast_pkts (yang:counter64)

    YANG Description: The number of packets, delivered by this sub-layer to a
higher (sub-)layer, that were not addressed to a
multicast or broadcast address at this sub-layer.
Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__in_unicast_pkts
      
  def _set_in_unicast_pkts(self, v, load=False):
    """
    Setter method for in_unicast_pkts, mapped from YANG variable /interfaces_state/interface/statistics/in_unicast_pkts (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_unicast_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_unicast_pkts() directly.

    YANG Description: The number of packets, delivered by this sub-layer to a
higher (sub-)layer, that were not addressed to a
multicast or broadcast address at this sub-layer.
Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_unicast_pkts must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)""",
        })

    self.__in_unicast_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_unicast_pkts(self):
    self.__in_unicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)


  def _get_in_broadcast_pkts(self):
    """
    Getter method for in_broadcast_pkts, mapped from YANG variable /interfaces_state/interface/statistics/in_broadcast_pkts (yang:counter64)

    YANG Description: The number of packets, delivered by this sub-layer to a
higher (sub-)layer, that were addressed to a broadcast
address at this sub-layer.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__in_broadcast_pkts
      
  def _set_in_broadcast_pkts(self, v, load=False):
    """
    Setter method for in_broadcast_pkts, mapped from YANG variable /interfaces_state/interface/statistics/in_broadcast_pkts (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_broadcast_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_broadcast_pkts() directly.

    YANG Description: The number of packets, delivered by this sub-layer to a
higher (sub-)layer, that were addressed to a broadcast
address at this sub-layer.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_broadcast_pkts must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)""",
        })

    self.__in_broadcast_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_broadcast_pkts(self):
    self.__in_broadcast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)


  def _get_in_multicast_pkts(self):
    """
    Getter method for in_multicast_pkts, mapped from YANG variable /interfaces_state/interface/statistics/in_multicast_pkts (yang:counter64)

    YANG Description: The number of packets, delivered by this sub-layer to a
higher (sub-)layer, that were addressed to a multicast
address at this sub-layer.  For a MAC-layer protocol,
this includes both Group and Functional addresses.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__in_multicast_pkts
      
  def _set_in_multicast_pkts(self, v, load=False):
    """
    Setter method for in_multicast_pkts, mapped from YANG variable /interfaces_state/interface/statistics/in_multicast_pkts (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_multicast_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_multicast_pkts() directly.

    YANG Description: The number of packets, delivered by this sub-layer to a
higher (sub-)layer, that were addressed to a multicast
address at this sub-layer.  For a MAC-layer protocol,
this includes both Group and Functional addresses.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_multicast_pkts must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)""",
        })

    self.__in_multicast_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_multicast_pkts(self):
    self.__in_multicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)


  def _get_in_discards(self):
    """
    Getter method for in_discards, mapped from YANG variable /interfaces_state/interface/statistics/in_discards (yang:counter32)

    YANG Description: The number of inbound packets that were chosen to be
discarded even though no errors had been detected to
prevent their being deliverable to a higher-layer
protocol.  One possible reason for discarding such a
packet could be to free up buffer space.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__in_discards
      
  def _set_in_discards(self, v, load=False):
    """
    Setter method for in_discards, mapped from YANG variable /interfaces_state/interface/statistics/in_discards (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_discards is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_discards() directly.

    YANG Description: The number of inbound packets that were chosen to be
discarded even though no errors had been detected to
prevent their being deliverable to a higher-layer
protocol.  One possible reason for discarding such a
packet could be to free up buffer space.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_discards must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)""",
        })

    self.__in_discards = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_discards(self):
    self.__in_discards = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)


  def _get_in_errors(self):
    """
    Getter method for in_errors, mapped from YANG variable /interfaces_state/interface/statistics/in_errors (yang:counter32)

    YANG Description: For packet-oriented interfaces, the number of inbound
packets that contained errors preventing them from being
deliverable to a higher-layer protocol.  For character-
oriented or fixed-length interfaces, the number of
inbound transmission units that contained errors
preventing them from being deliverable to a higher-layer
protocol.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__in_errors
      
  def _set_in_errors(self, v, load=False):
    """
    Setter method for in_errors, mapped from YANG variable /interfaces_state/interface/statistics/in_errors (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_errors() directly.

    YANG Description: For packet-oriented interfaces, the number of inbound
packets that contained errors preventing them from being
deliverable to a higher-layer protocol.  For character-
oriented or fixed-length interfaces, the number of
inbound transmission units that contained errors
preventing them from being deliverable to a higher-layer
protocol.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_errors must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)""",
        })

    self.__in_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_errors(self):
    self.__in_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)


  def _get_in_unknown_protos(self):
    """
    Getter method for in_unknown_protos, mapped from YANG variable /interfaces_state/interface/statistics/in_unknown_protos (yang:counter32)

    YANG Description: For packet-oriented interfaces, the number of packets
received via the interface that were discarded because
of an unknown or unsupported protocol.  For
character-oriented or fixed-length interfaces that
support protocol multiplexing, the number of
transmission units received via the interface that were
discarded because of an unknown or unsupported protocol.
For any interface that does not support protocol
multiplexing, this counter is not present.
Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__in_unknown_protos
      
  def _set_in_unknown_protos(self, v, load=False):
    """
    Setter method for in_unknown_protos, mapped from YANG variable /interfaces_state/interface/statistics/in_unknown_protos (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_unknown_protos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_unknown_protos() directly.

    YANG Description: For packet-oriented interfaces, the number of packets
received via the interface that were discarded because
of an unknown or unsupported protocol.  For
character-oriented or fixed-length interfaces that
support protocol multiplexing, the number of
transmission units received via the interface that were
discarded because of an unknown or unsupported protocol.
For any interface that does not support protocol
multiplexing, this counter is not present.
Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-unknown-protos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_unknown_protos must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-unknown-protos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)""",
        })

    self.__in_unknown_protos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_unknown_protos(self):
    self.__in_unknown_protos = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-unknown-protos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)


  def _get_out_octets(self):
    """
    Getter method for out_octets, mapped from YANG variable /interfaces_state/interface/statistics/out_octets (yang:counter64)

    YANG Description: The total number of octets transmitted out of the
interface, including framing characters.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__out_octets
      
  def _set_out_octets(self, v, load=False):
    """
    Setter method for out_octets, mapped from YANG variable /interfaces_state/interface/statistics/out_octets (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_octets() directly.

    YANG Description: The total number of octets transmitted out of the
interface, including framing characters.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_octets must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)""",
        })

    self.__out_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_octets(self):
    self.__out_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)


  def _get_out_unicast_pkts(self):
    """
    Getter method for out_unicast_pkts, mapped from YANG variable /interfaces_state/interface/statistics/out_unicast_pkts (yang:counter64)

    YANG Description: The total number of packets that higher-level protocols
requested be transmitted and that were not addressed
to a multicast or broadcast address at this sub-layer,
including those that were discarded or not sent.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__out_unicast_pkts
      
  def _set_out_unicast_pkts(self, v, load=False):
    """
    Setter method for out_unicast_pkts, mapped from YANG variable /interfaces_state/interface/statistics/out_unicast_pkts (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_unicast_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_unicast_pkts() directly.

    YANG Description: The total number of packets that higher-level protocols
requested be transmitted and that were not addressed
to a multicast or broadcast address at this sub-layer,
including those that were discarded or not sent.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_unicast_pkts must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)""",
        })

    self.__out_unicast_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_unicast_pkts(self):
    self.__out_unicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)


  def _get_out_broadcast_pkts(self):
    """
    Getter method for out_broadcast_pkts, mapped from YANG variable /interfaces_state/interface/statistics/out_broadcast_pkts (yang:counter64)

    YANG Description: The total number of packets that higher-level protocols
requested be transmitted and that were addressed to a
broadcast address at this sub-layer, including those
that were discarded or not sent.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__out_broadcast_pkts
      
  def _set_out_broadcast_pkts(self, v, load=False):
    """
    Setter method for out_broadcast_pkts, mapped from YANG variable /interfaces_state/interface/statistics/out_broadcast_pkts (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_broadcast_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_broadcast_pkts() directly.

    YANG Description: The total number of packets that higher-level protocols
requested be transmitted and that were addressed to a
broadcast address at this sub-layer, including those
that were discarded or not sent.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_broadcast_pkts must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)""",
        })

    self.__out_broadcast_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_broadcast_pkts(self):
    self.__out_broadcast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)


  def _get_out_multicast_pkts(self):
    """
    Getter method for out_multicast_pkts, mapped from YANG variable /interfaces_state/interface/statistics/out_multicast_pkts (yang:counter64)

    YANG Description: The total number of packets that higher-level protocols
requested be transmitted and that were addressed to a
multicast address at this sub-layer, including those
that were discarded or not sent.  For a MAC-layer
protocol, this includes both Group and Functional
addresses.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__out_multicast_pkts
      
  def _set_out_multicast_pkts(self, v, load=False):
    """
    Setter method for out_multicast_pkts, mapped from YANG variable /interfaces_state/interface/statistics/out_multicast_pkts (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_multicast_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_multicast_pkts() directly.

    YANG Description: The total number of packets that higher-level protocols
requested be transmitted and that were addressed to a
multicast address at this sub-layer, including those
that were discarded or not sent.  For a MAC-layer
protocol, this includes both Group and Functional
addresses.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_multicast_pkts must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)""",
        })

    self.__out_multicast_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_multicast_pkts(self):
    self.__out_multicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)


  def _get_out_discards(self):
    """
    Getter method for out_discards, mapped from YANG variable /interfaces_state/interface/statistics/out_discards (yang:counter32)

    YANG Description: The number of outbound packets that were chosen to be
discarded even though no errors had been detected to
prevent their being transmitted.  One possible reason
for discarding such a packet could be to free up buffer
space.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__out_discards
      
  def _set_out_discards(self, v, load=False):
    """
    Setter method for out_discards, mapped from YANG variable /interfaces_state/interface/statistics/out_discards (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_discards is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_discards() directly.

    YANG Description: The number of outbound packets that were chosen to be
discarded even though no errors had been detected to
prevent their being transmitted.  One possible reason
for discarding such a packet could be to free up buffer
space.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_discards must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)""",
        })

    self.__out_discards = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_discards(self):
    self.__out_discards = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)


  def _get_out_errors(self):
    """
    Getter method for out_errors, mapped from YANG variable /interfaces_state/interface/statistics/out_errors (yang:counter32)

    YANG Description: For packet-oriented interfaces, the number of outbound
packets that could not be transmitted because of errors.
For character-oriented or fixed-length interfaces, the
number of outbound transmission units that could not be
transmitted because of errors.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__out_errors
      
  def _set_out_errors(self, v, load=False):
    """
    Setter method for out_errors, mapped from YANG variable /interfaces_state/interface/statistics/out_errors (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_errors() directly.

    YANG Description: For packet-oriented interfaces, the number of outbound
packets that could not be transmitted because of errors.
For character-oriented or fixed-length interfaces, the
number of outbound transmission units that could not be
transmitted because of errors.

Discontinuities in the value of this counter can occur
at re-initialization of the management system and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_errors must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)""",
        })

    self.__out_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_errors(self):
    self.__out_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)

  discontinuity_time = __builtin__.property(_get_discontinuity_time)
  in_octets = __builtin__.property(_get_in_octets)
  in_unicast_pkts = __builtin__.property(_get_in_unicast_pkts)
  in_broadcast_pkts = __builtin__.property(_get_in_broadcast_pkts)
  in_multicast_pkts = __builtin__.property(_get_in_multicast_pkts)
  in_discards = __builtin__.property(_get_in_discards)
  in_errors = __builtin__.property(_get_in_errors)
  in_unknown_protos = __builtin__.property(_get_in_unknown_protos)
  out_octets = __builtin__.property(_get_out_octets)
  out_unicast_pkts = __builtin__.property(_get_out_unicast_pkts)
  out_broadcast_pkts = __builtin__.property(_get_out_broadcast_pkts)
  out_multicast_pkts = __builtin__.property(_get_out_multicast_pkts)
  out_discards = __builtin__.property(_get_out_discards)
  out_errors = __builtin__.property(_get_out_errors)


  _pyangbind_elements = OrderedDict([('discontinuity_time', discontinuity_time), ('in_octets', in_octets), ('in_unicast_pkts', in_unicast_pkts), ('in_broadcast_pkts', in_broadcast_pkts), ('in_multicast_pkts', in_multicast_pkts), ('in_discards', in_discards), ('in_errors', in_errors), ('in_unknown_protos', in_unknown_protos), ('out_octets', out_octets), ('out_unicast_pkts', out_unicast_pkts), ('out_broadcast_pkts', out_broadcast_pkts), ('out_multicast_pkts', out_multicast_pkts), ('out_discards', out_discards), ('out_errors', out_errors), ])


class yc_interface_ietf_interfaces__interfaces_state_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-interfaces - based on the path /interfaces-state/interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of interfaces on the device.

System-controlled interfaces created by the system are
always present in this list, whether or not they are
configured.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__type','__admin_status','__oper_status','__last_change','__if_index','__phys_address','__higher_layer_if','__lower_layer_if','__speed','__statistics',)

  _yang_name = 'interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__statistics = YANGDynClass(base=yc_statistics_ietf_interfaces__interfaces_state_interface_statistics, is_container='container', yang_name="statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=False)
    self.__if_index = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={u'range': [u'1..2147483647']}), is_leaf=True, yang_name="if-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='int32', is_config=False)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='string', is_config=False)
    self.__higher_layer_if = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="higher-layer-if", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='interface-state-ref', is_config=False)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='identityref', is_config=False)
    self.__admin_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'down': {u'value': 2}, u'testing': {u'value': 3}, u'up': {u'value': 1}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=False)
    self.__oper_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'dormant': {u'value': 5}, u'lower-layer-down': {u'value': 7}, u'unknown': {u'value': 4}, u'testing': {u'value': 3}, u'up': {u'value': 1}, u'down': {u'value': 2}, u'not-present': {u'value': 6}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=False)
    self.__lower_layer_if = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="lower-layer-if", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='interface-state-ref', is_config=False)
    self.__last_change = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-change", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:date-and-time', is_config=False)
    self.__speed = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:gauge64', is_config=False)
    self.__phys_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="phys-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:phys-address', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'interfaces-state', u'interface']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /interfaces_state/interface/name (string)

    YANG Description: The name of the interface.

A server implementation MAY map this leaf to the ifName
MIB object.  Such an implementation needs to use some
mechanism to handle the differences in size and characters
allowed between this leaf and ifName.  The definition of
such a mechanism is outside the scope of this document.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /interfaces_state/interface/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the interface.

A server implementation MAY map this leaf to the ifName
MIB object.  Such an implementation needs to use some
mechanism to handle the differences in size and characters
allowed between this leaf and ifName.  The definition of
such a mechanism is outside the scope of this document.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='string', is_config=False)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /interfaces_state/interface/type (identityref)

    YANG Description: The type of the interface.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /interfaces_state/interface/type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: The type of the interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with identityref""",
          'defined-type': "ietf-interfaces:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='identityref', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='identityref', is_config=False)


  def _get_admin_status(self):
    """
    Getter method for admin_status, mapped from YANG variable /interfaces_state/interface/admin_status (enumeration)

    YANG Description: The desired state of the interface.

This leaf has the same read semantics as ifAdminStatus.
    """
    return self.__admin_status
      
  def _set_admin_status(self, v, load=False):
    """
    Setter method for admin_status, mapped from YANG variable /interfaces_state/interface/admin_status (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_status() directly.

    YANG Description: The desired state of the interface.

This leaf has the same read semantics as ifAdminStatus.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'down': {u'value': 2}, u'testing': {u'value': 3}, u'up': {u'value': 1}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_status must be of a type compatible with enumeration""",
          'defined-type': "ietf-interfaces:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'down': {u'value': 2}, u'testing': {u'value': 3}, u'up': {u'value': 1}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=False)""",
        })

    self.__admin_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_status(self):
    self.__admin_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'down': {u'value': 2}, u'testing': {u'value': 3}, u'up': {u'value': 1}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=False)


  def _get_oper_status(self):
    """
    Getter method for oper_status, mapped from YANG variable /interfaces_state/interface/oper_status (enumeration)

    YANG Description: The current operational state of the interface.

This leaf has the same semantics as ifOperStatus.
    """
    return self.__oper_status
      
  def _set_oper_status(self, v, load=False):
    """
    Setter method for oper_status, mapped from YANG variable /interfaces_state/interface/oper_status (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oper_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oper_status() directly.

    YANG Description: The current operational state of the interface.

This leaf has the same semantics as ifOperStatus.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'dormant': {u'value': 5}, u'lower-layer-down': {u'value': 7}, u'unknown': {u'value': 4}, u'testing': {u'value': 3}, u'up': {u'value': 1}, u'down': {u'value': 2}, u'not-present': {u'value': 6}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oper_status must be of a type compatible with enumeration""",
          'defined-type': "ietf-interfaces:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'dormant': {u'value': 5}, u'lower-layer-down': {u'value': 7}, u'unknown': {u'value': 4}, u'testing': {u'value': 3}, u'up': {u'value': 1}, u'down': {u'value': 2}, u'not-present': {u'value': 6}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=False)""",
        })

    self.__oper_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oper_status(self):
    self.__oper_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'dormant': {u'value': 5}, u'lower-layer-down': {u'value': 7}, u'unknown': {u'value': 4}, u'testing': {u'value': 3}, u'up': {u'value': 1}, u'down': {u'value': 2}, u'not-present': {u'value': 6}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=False)


  def _get_last_change(self):
    """
    Getter method for last_change, mapped from YANG variable /interfaces_state/interface/last_change (yang:date-and-time)

    YANG Description: The time the interface entered its current operational
state.  If the current state was entered prior to the
last re-initialization of the local network management
subsystem, then this node is not present.
    """
    return self.__last_change
      
  def _set_last_change(self, v, load=False):
    """
    Setter method for last_change, mapped from YANG variable /interfaces_state/interface/last_change (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_change is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_change() directly.

    YANG Description: The time the interface entered its current operational
state.  If the current state was entered prior to the
last re-initialization of the local network management
subsystem, then this node is not present.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-change", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_change must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-change", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__last_change = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_change(self):
    self.__last_change = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-change", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:date-and-time', is_config=False)


  def _get_if_index(self):
    """
    Getter method for if_index, mapped from YANG variable /interfaces_state/interface/if_index (int32)

    YANG Description: The ifIndex value for the ifEntry represented by this
interface.
    """
    return self.__if_index
      
  def _set_if_index(self, v, load=False):
    """
    Setter method for if_index, mapped from YANG variable /interfaces_state/interface/if_index (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_if_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_if_index() directly.

    YANG Description: The ifIndex value for the ifEntry represented by this
interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={u'range': [u'1..2147483647']}), is_leaf=True, yang_name="if-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """if_index must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={u'range': [u'1..2147483647']}), is_leaf=True, yang_name="if-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='int32', is_config=False)""",
        })

    self.__if_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_if_index(self):
    self.__if_index = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={u'range': [u'1..2147483647']}), is_leaf=True, yang_name="if-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='int32', is_config=False)


  def _get_phys_address(self):
    """
    Getter method for phys_address, mapped from YANG variable /interfaces_state/interface/phys_address (yang:phys-address)

    YANG Description: The interface's address at its protocol sub-layer.  For
example, for an 802.x interface, this object normally
contains a Media Access Control (MAC) address.  The
interface's media-specific modules must define the bit
and byte ordering and the format of the value of this
object.  For interfaces that do not have such an address
(e.g., a serial line), this node is not present.
    """
    return self.__phys_address
      
  def _set_phys_address(self, v, load=False):
    """
    Setter method for phys_address, mapped from YANG variable /interfaces_state/interface/phys_address (yang:phys-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_phys_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_phys_address() directly.

    YANG Description: The interface's address at its protocol sub-layer.  For
example, for an 802.x interface, this object normally
contains a Media Access Control (MAC) address.  The
interface's media-specific modules must define the bit
and byte ordering and the format of the value of this
object.  For interfaces that do not have such an address
(e.g., a serial line), this node is not present.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="phys-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:phys-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """phys_address must be of a type compatible with yang:phys-address""",
          'defined-type': "yang:phys-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="phys-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:phys-address', is_config=False)""",
        })

    self.__phys_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_phys_address(self):
    self.__phys_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="phys-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:phys-address', is_config=False)


  def _get_higher_layer_if(self):
    """
    Getter method for higher_layer_if, mapped from YANG variable /interfaces_state/interface/higher_layer_if (interface-state-ref)

    YANG Description: A list of references to interfaces layered on top of this
interface.
    """
    return self.__higher_layer_if
      
  def _set_higher_layer_if(self, v, load=False):
    """
    Setter method for higher_layer_if, mapped from YANG variable /interfaces_state/interface/higher_layer_if (interface-state-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_higher_layer_if is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_higher_layer_if() directly.

    YANG Description: A list of references to interfaces layered on top of this
interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="higher-layer-if", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='interface-state-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """higher_layer_if must be of a type compatible with interface-state-ref""",
          'defined-type': "ietf-interfaces:interface-state-ref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="higher-layer-if", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='interface-state-ref', is_config=False)""",
        })

    self.__higher_layer_if = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_higher_layer_if(self):
    self.__higher_layer_if = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="higher-layer-if", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='interface-state-ref', is_config=False)


  def _get_lower_layer_if(self):
    """
    Getter method for lower_layer_if, mapped from YANG variable /interfaces_state/interface/lower_layer_if (interface-state-ref)

    YANG Description: A list of references to interfaces layered underneath this
interface.
    """
    return self.__lower_layer_if
      
  def _set_lower_layer_if(self, v, load=False):
    """
    Setter method for lower_layer_if, mapped from YANG variable /interfaces_state/interface/lower_layer_if (interface-state-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lower_layer_if is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lower_layer_if() directly.

    YANG Description: A list of references to interfaces layered underneath this
interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="lower-layer-if", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='interface-state-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lower_layer_if must be of a type compatible with interface-state-ref""",
          'defined-type': "ietf-interfaces:interface-state-ref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="lower-layer-if", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='interface-state-ref', is_config=False)""",
        })

    self.__lower_layer_if = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lower_layer_if(self):
    self.__lower_layer_if = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="lower-layer-if", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='interface-state-ref', is_config=False)


  def _get_speed(self):
    """
    Getter method for speed, mapped from YANG variable /interfaces_state/interface/speed (yang:gauge64)

    YANG Description: An estimate of the interface's current bandwidth in bits
per second.  For interfaces that do not vary in
bandwidth or for those where no accurate estimation can

be made, this node should contain the nominal bandwidth.
For interfaces that have no concept of bandwidth, this
node is not present.
    """
    return self.__speed
      
  def _set_speed(self, v, load=False):
    """
    Setter method for speed, mapped from YANG variable /interfaces_state/interface/speed (yang:gauge64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_speed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_speed() directly.

    YANG Description: An estimate of the interface's current bandwidth in bits
per second.  For interfaces that do not vary in
bandwidth or for those where no accurate estimation can

be made, this node should contain the nominal bandwidth.
For interfaces that have no concept of bandwidth, this
node is not present.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:gauge64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """speed must be of a type compatible with yang:gauge64""",
          'defined-type': "yang:gauge64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:gauge64', is_config=False)""",
        })

    self.__speed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_speed(self):
    self.__speed = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:gauge64', is_config=False)


  def _get_statistics(self):
    """
    Getter method for statistics, mapped from YANG variable /interfaces_state/interface/statistics (container)

    YANG Description: A collection of interface-related statistics objects.
    """
    return self.__statistics
      
  def _set_statistics(self, v, load=False):
    """
    Setter method for statistics, mapped from YANG variable /interfaces_state/interface/statistics (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_statistics is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_statistics() directly.

    YANG Description: A collection of interface-related statistics objects.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_statistics_ietf_interfaces__interfaces_state_interface_statistics, is_container='container', yang_name="statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """statistics must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_statistics_ietf_interfaces__interfaces_state_interface_statistics, is_container='container', yang_name="statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=False)""",
        })

    self.__statistics = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_statistics(self):
    self.__statistics = YANGDynClass(base=yc_statistics_ietf_interfaces__interfaces_state_interface_statistics, is_container='container', yang_name="statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=False)

  name = __builtin__.property(_get_name)
  type = __builtin__.property(_get_type)
  admin_status = __builtin__.property(_get_admin_status)
  oper_status = __builtin__.property(_get_oper_status)
  last_change = __builtin__.property(_get_last_change)
  if_index = __builtin__.property(_get_if_index)
  phys_address = __builtin__.property(_get_phys_address)
  higher_layer_if = __builtin__.property(_get_higher_layer_if)
  lower_layer_if = __builtin__.property(_get_lower_layer_if)
  speed = __builtin__.property(_get_speed)
  statistics = __builtin__.property(_get_statistics)


  _pyangbind_elements = OrderedDict([('name', name), ('type', type), ('admin_status', admin_status), ('oper_status', oper_status), ('last_change', last_change), ('if_index', if_index), ('phys_address', phys_address), ('higher_layer_if', higher_layer_if), ('lower_layer_if', lower_layer_if), ('speed', speed), ('statistics', statistics), ])


class yc_interfaces_state_ietf_interfaces__interfaces_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-interfaces - based on the path /interfaces-state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Data nodes for the operational state of interfaces.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface',)

  _yang_name = 'interfaces-state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(base=YANGListType("name",yc_interface_ietf_interfaces__interfaces_state_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'interfaces-state']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /interfaces_state/interface (list)

    YANG Description: The list of interfaces on the device.

System-controlled interfaces created by the system are
always present in this list, whether or not they are
configured.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /interfaces_state/interface (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: The list of interfaces on the device.

System-controlled interfaces created by the system are
always present in this list, whether or not they are
configured.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_interface_ietf_interfaces__interfaces_state_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_interface_ietf_interfaces__interfaces_state_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='list', is_config=False)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=YANGListType("name",yc_interface_ietf_interfaces__interfaces_state_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='list', is_config=False)

  interface = __builtin__.property(_get_interface)


  _pyangbind_elements = OrderedDict([('interface', interface), ])


class ietf_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-interfaces - based on the path /ietf-interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains a collection of YANG definitions for
managing network interfaces.

Copyright (c) 2018 IETF Trust and the persons identified as
authors of the code.  All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject
to the license terms contained in, the Simplified BSD License
set forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(https://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC 8343; see
the RFC itself for full legal notices.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interfaces','__interfaces_state',)

  _yang_name = 'ietf-interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interfaces = YANGDynClass(base=yc_interfaces_ietf_interfaces__interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=True)
    self.__interfaces_state = YANGDynClass(base=yc_interfaces_state_ietf_interfaces__interfaces_state, is_container='container', yang_name="interfaces-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_interfaces(self):
    """
    Getter method for interfaces, mapped from YANG variable /interfaces (container)

    YANG Description: Interface parameters.
    """
    return self.__interfaces
      
  def _set_interfaces(self, v, load=False):
    """
    Setter method for interfaces, mapped from YANG variable /interfaces (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaces() directly.

    YANG Description: Interface parameters.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_interfaces_ietf_interfaces__interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaces must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_interfaces_ietf_interfaces__interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=True)""",
        })

    self.__interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaces(self):
    self.__interfaces = YANGDynClass(base=yc_interfaces_ietf_interfaces__interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=True)


  def _get_interfaces_state(self):
    """
    Getter method for interfaces_state, mapped from YANG variable /interfaces_state (container)

    YANG Description: Data nodes for the operational state of interfaces.
    """
    return self.__interfaces_state
      
  def _set_interfaces_state(self, v, load=False):
    """
    Setter method for interfaces_state, mapped from YANG variable /interfaces_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaces_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaces_state() directly.

    YANG Description: Data nodes for the operational state of interfaces.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_interfaces_state_ietf_interfaces__interfaces_state, is_container='container', yang_name="interfaces-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaces_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_interfaces_state_ietf_interfaces__interfaces_state, is_container='container', yang_name="interfaces-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=True)""",
        })

    self.__interfaces_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaces_state(self):
    self.__interfaces_state = YANGDynClass(base=yc_interfaces_state_ietf_interfaces__interfaces_state, is_container='container', yang_name="interfaces-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=True)

  interfaces = __builtin__.property(_get_interfaces, _set_interfaces)
  interfaces_state = __builtin__.property(_get_interfaces_state, _set_interfaces_state)


  _pyangbind_elements = OrderedDict([('interfaces', interfaces), ('interfaces_state', interfaces_state), ])


class yc_supporting_network_ietf_network_state__networks_network_supporting_network(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-network-state - based on the path /networks/network/supporting-network. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An underlay network, used to represent layered network
topologies.
  """
  __slots__ = ('_path_helper', '_extmethods', '__network_ref',)

  _yang_name = 'supporting-network'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__network_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='leafref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'networks', u'network', u'supporting-network']

  def _get_network_ref(self):
    """
    Getter method for network_ref, mapped from YANG variable /networks/network/supporting_network/network_ref (leafref)

    YANG Description: References the underlay network.
    """
    return self.__network_ref
      
  def _set_network_ref(self, v, load=False):
    """
    Setter method for network_ref, mapped from YANG variable /networks/network/supporting_network/network_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_ref() directly.

    YANG Description: References the underlay network.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="network-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='leafref', is_config=False)""",
        })

    self.__network_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_ref(self):
    self.__network_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='leafref', is_config=False)

  network_ref = __builtin__.property(_get_network_ref)


  _pyangbind_elements = OrderedDict([('network_ref', network_ref), ])


class yc_supporting_node_ietf_network_state__networks_network_node_supporting_node(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-network-state - based on the path /networks/network/node/supporting-node. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Represents another node that is in an underlay network
and that supports this node.  Used to represent layering
structure.
  """
  __slots__ = ('_path_helper', '_extmethods', '__network_ref','__node_ref',)

  _yang_name = 'supporting-node'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__node_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="node-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='leafref', is_config=False)
    self.__network_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='leafref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'networks', u'network', u'node', u'supporting-node']

  def _get_network_ref(self):
    """
    Getter method for network_ref, mapped from YANG variable /networks/network/node/supporting_node/network_ref (leafref)

    YANG Description: References the underlay network of which the
underlay node is a part.
    """
    return self.__network_ref
      
  def _set_network_ref(self, v, load=False):
    """
    Setter method for network_ref, mapped from YANG variable /networks/network/node/supporting_node/network_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_ref() directly.

    YANG Description: References the underlay network of which the
underlay node is a part.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="network-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='leafref', is_config=False)""",
        })

    self.__network_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_ref(self):
    self.__network_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='leafref', is_config=False)


  def _get_node_ref(self):
    """
    Getter method for node_ref, mapped from YANG variable /networks/network/node/supporting_node/node_ref (leafref)

    YANG Description: References the underlay node itself.
    """
    return self.__node_ref
      
  def _set_node_ref(self, v, load=False):
    """
    Setter method for node_ref, mapped from YANG variable /networks/network/node/supporting_node/node_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_node_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_node_ref() directly.

    YANG Description: References the underlay node itself.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="node-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """node_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="node-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='leafref', is_config=False)""",
        })

    self.__node_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_node_ref(self):
    self.__node_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="node-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='leafref', is_config=False)

  network_ref = __builtin__.property(_get_network_ref)
  node_ref = __builtin__.property(_get_node_ref)


  _pyangbind_elements = OrderedDict([('network_ref', network_ref), ('node_ref', node_ref), ])


class yc_node_ietf_network_state__networks_network_node(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-network-state - based on the path /networks/network/node. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The inventory of nodes of this network.
  """
  __slots__ = ('_path_helper', '_extmethods', '__node_id','__supporting_node',)

  _yang_name = 'node'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__node_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="node-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='nw:node-id', is_config=False)
    self.__supporting_node = YANGDynClass(base=YANGListType("network_ref node_ref",yc_supporting_node_ietf_network_state__networks_network_node_supporting_node, yang_name="supporting-node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-ref node-ref', extensions=None), is_container='list', yang_name="supporting-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'networks', u'network', u'node']

  def _get_node_id(self):
    """
    Getter method for node_id, mapped from YANG variable /networks/network/node/node_id (nw:node-id)

    YANG Description: Uniquely identifies a node within the containing
network.
    """
    return self.__node_id
      
  def _set_node_id(self, v, load=False):
    """
    Setter method for node_id, mapped from YANG variable /networks/network/node/node_id (nw:node-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_node_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_node_id() directly.

    YANG Description: Uniquely identifies a node within the containing
network.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="node-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='nw:node-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """node_id must be of a type compatible with nw:node-id""",
          'defined-type': "nw:node-id",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="node-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='nw:node-id', is_config=False)""",
        })

    self.__node_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_node_id(self):
    self.__node_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="node-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='nw:node-id', is_config=False)


  def _get_supporting_node(self):
    """
    Getter method for supporting_node, mapped from YANG variable /networks/network/node/supporting_node (list)

    YANG Description: Represents another node that is in an underlay network
and that supports this node.  Used to represent layering
structure.
    """
    return self.__supporting_node
      
  def _set_supporting_node(self, v, load=False):
    """
    Setter method for supporting_node, mapped from YANG variable /networks/network/node/supporting_node (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supporting_node is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supporting_node() directly.

    YANG Description: Represents another node that is in an underlay network
and that supports this node.  Used to represent layering
structure.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("network_ref node_ref",yc_supporting_node_ietf_network_state__networks_network_node_supporting_node, yang_name="supporting-node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-ref node-ref', extensions=None), is_container='list', yang_name="supporting-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supporting_node must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("network_ref node_ref",yc_supporting_node_ietf_network_state__networks_network_node_supporting_node, yang_name="supporting-node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-ref node-ref', extensions=None), is_container='list', yang_name="supporting-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='list', is_config=False)""",
        })

    self.__supporting_node = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supporting_node(self):
    self.__supporting_node = YANGDynClass(base=YANGListType("network_ref node_ref",yc_supporting_node_ietf_network_state__networks_network_node_supporting_node, yang_name="supporting-node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-ref node-ref', extensions=None), is_container='list', yang_name="supporting-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='list', is_config=False)

  node_id = __builtin__.property(_get_node_id)
  supporting_node = __builtin__.property(_get_supporting_node)


  _pyangbind_elements = OrderedDict([('node_id', node_id), ('supporting_node', supporting_node), ])


class yc_network_ietf_network_state__networks_network(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-network-state - based on the path /networks/network. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Describes a network.
A network typically contains an inventory of nodes,
topological information (augmented through the
network-topology data model), and layering information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__network_id','__supporting_network','__node',)

  _yang_name = 'network'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__network_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='nw:network-id', is_config=False)
    self.__node = YANGDynClass(base=YANGListType("node_id",yc_node_ietf_network_state__networks_network_node, yang_name="node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='node-id', extensions=None), is_container='list', yang_name="node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='list', is_config=False)
    self.__supporting_network = YANGDynClass(base=YANGListType("network_ref",yc_supporting_network_ietf_network_state__networks_network_supporting_network, yang_name="supporting-network", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-ref', extensions=None), is_container='list', yang_name="supporting-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'networks', u'network']

  def _get_network_id(self):
    """
    Getter method for network_id, mapped from YANG variable /networks/network/network_id (nw:network-id)

    YANG Description: Identifies a network.
    """
    return self.__network_id
      
  def _set_network_id(self, v, load=False):
    """
    Setter method for network_id, mapped from YANG variable /networks/network/network_id (nw:network-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_id() directly.

    YANG Description: Identifies a network.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="network-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='nw:network-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_id must be of a type compatible with nw:network-id""",
          'defined-type': "nw:network-id",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='nw:network-id', is_config=False)""",
        })

    self.__network_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_id(self):
    self.__network_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='nw:network-id', is_config=False)


  def _get_supporting_network(self):
    """
    Getter method for supporting_network, mapped from YANG variable /networks/network/supporting_network (list)

    YANG Description: An underlay network, used to represent layered network
topologies.
    """
    return self.__supporting_network
      
  def _set_supporting_network(self, v, load=False):
    """
    Setter method for supporting_network, mapped from YANG variable /networks/network/supporting_network (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supporting_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supporting_network() directly.

    YANG Description: An underlay network, used to represent layered network
topologies.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("network_ref",yc_supporting_network_ietf_network_state__networks_network_supporting_network, yang_name="supporting-network", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-ref', extensions=None), is_container='list', yang_name="supporting-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supporting_network must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("network_ref",yc_supporting_network_ietf_network_state__networks_network_supporting_network, yang_name="supporting-network", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-ref', extensions=None), is_container='list', yang_name="supporting-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='list', is_config=False)""",
        })

    self.__supporting_network = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supporting_network(self):
    self.__supporting_network = YANGDynClass(base=YANGListType("network_ref",yc_supporting_network_ietf_network_state__networks_network_supporting_network, yang_name="supporting-network", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-ref', extensions=None), is_container='list', yang_name="supporting-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='list', is_config=False)


  def _get_node(self):
    """
    Getter method for node, mapped from YANG variable /networks/network/node (list)

    YANG Description: The inventory of nodes of this network.
    """
    return self.__node
      
  def _set_node(self, v, load=False):
    """
    Setter method for node, mapped from YANG variable /networks/network/node (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_node is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_node() directly.

    YANG Description: The inventory of nodes of this network.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("node_id",yc_node_ietf_network_state__networks_network_node, yang_name="node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='node-id', extensions=None), is_container='list', yang_name="node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """node must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("node_id",yc_node_ietf_network_state__networks_network_node, yang_name="node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='node-id', extensions=None), is_container='list', yang_name="node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='list', is_config=False)""",
        })

    self.__node = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_node(self):
    self.__node = YANGDynClass(base=YANGListType("node_id",yc_node_ietf_network_state__networks_network_node, yang_name="node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='node-id', extensions=None), is_container='list', yang_name="node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='list', is_config=False)

  network_id = __builtin__.property(_get_network_id)
  supporting_network = __builtin__.property(_get_supporting_network)
  node = __builtin__.property(_get_node)


  _pyangbind_elements = OrderedDict([('network_id', network_id), ('supporting_network', supporting_network), ('node', node), ])


class yc_networks_ietf_network_state__networks(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-network-state - based on the path /networks. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Serves as a top-level container for a list of networks.
  """
  __slots__ = ('_path_helper', '_extmethods', '__network',)

  _yang_name = 'networks'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__network = YANGDynClass(base=YANGListType("network_id",yc_network_ietf_network_state__networks_network, yang_name="network", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-id', extensions=None), is_container='list', yang_name="network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'networks']

  def _get_network(self):
    """
    Getter method for network, mapped from YANG variable /networks/network (list)

    YANG Description: Describes a network.
A network typically contains an inventory of nodes,
topological information (augmented through the
network-topology data model), and layering information.
    """
    return self.__network
      
  def _set_network(self, v, load=False):
    """
    Setter method for network, mapped from YANG variable /networks/network (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network() directly.

    YANG Description: Describes a network.
A network typically contains an inventory of nodes,
topological information (augmented through the
network-topology data model), and layering information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("network_id",yc_network_ietf_network_state__networks_network, yang_name="network", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-id', extensions=None), is_container='list', yang_name="network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("network_id",yc_network_ietf_network_state__networks_network, yang_name="network", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-id', extensions=None), is_container='list', yang_name="network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='list', is_config=False)""",
        })

    self.__network = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network(self):
    self.__network = YANGDynClass(base=YANGListType("network_id",yc_network_ietf_network_state__networks_network, yang_name="network", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-id', extensions=None), is_container='list', yang_name="network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='list', is_config=False)

  network = __builtin__.property(_get_network)


  _pyangbind_elements = OrderedDict([('network', network), ])


class ietf_network_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-network-state - based on the path /ietf-network-state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines a common base data model for a collection
of nodes in a network.  Node definitions are further used
in network topologies and inventories.  It represents
information that either (1) is learned and automatically
populated or (2) results from applying network information
that has been configured per the 'ietf-network' data model,
mirroring the corresponding data nodes in this data model.

The data model mirrors 'ietf-network' but contains only
read-only state data.  The data model is not needed when the
underlying implementation infrastructure supports the Network
Management Datastore Architecture (NMDA).

Copyright (c) 2018 IETF Trust and the persons identified as
authors of the code.  All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject
to the license terms contained in, the Simplified BSD License
set forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(https://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC 8345;
see the RFC itself for full legal notices.
  """
  __slots__ = ('_path_helper', '_extmethods', '__networks',)

  _yang_name = 'ietf-network-state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__networks = YANGDynClass(base=yc_networks_ietf_network_state__networks, is_container='container', yang_name="networks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_networks(self):
    """
    Getter method for networks, mapped from YANG variable /networks (container)

    YANG Description: Serves as a top-level container for a list of networks.
    """
    return self.__networks
      
  def _set_networks(self, v, load=False):
    """
    Setter method for networks, mapped from YANG variable /networks (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_networks is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_networks() directly.

    YANG Description: Serves as a top-level container for a list of networks.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_networks_ietf_network_state__networks, is_container='container', yang_name="networks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """networks must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_networks_ietf_network_state__networks, is_container='container', yang_name="networks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='container', is_config=True)""",
        })

    self.__networks = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_networks(self):
    self.__networks = YANGDynClass(base=yc_networks_ietf_network_state__networks, is_container='container', yang_name="networks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-state', defining_module='ietf-network-state', yang_type='container', is_config=True)

  networks = __builtin__.property(_get_networks, _set_networks)


  _pyangbind_elements = OrderedDict([('networks', networks), ])


class ietf_inet_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-inet-types - based on the path /ietf-inet-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains a collection of generally useful derived
YANG data types for Internet addresses and related things.

Copyright (c) 2013 IETF Trust and the persons identified as
authors of the code.  All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject
to the license terms contained in, the Simplified BSD License
set forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(http://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC 6991; see
the RFC itself for full legal notices.
  """
  _pyangbind_elements = {}

  

class iana_routing_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module iana-routing-types - based on the path /iana-routing-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains a collection of YANG data types
considered defined by IANA and used for routing
protocols.

Copyright (c) 2017 IETF Trust and the persons
identified as authors of the code.  All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject
to the license terms contained in, the Simplified BSD License
set forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(https://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC 8294; see
the RFC itself for full legal notices.
  """
  _pyangbind_elements = {}

  

class ietf_routing_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing-types - based on the path /ietf-routing-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains a collection of YANG data types
considered generally useful for routing protocols.

Copyright (c) 2017 IETF Trust and the persons
identified as authors of the code.  All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject
to the license terms contained in, the Simplified BSD License
set forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(https://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC 8294; see
the RFC itself for full legal notices.
  """
  _pyangbind_elements = {}

  

class ietf_yang_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-yang-types - based on the path /ietf-yang-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains a collection of generally useful derived
YANG data types.

Copyright (c) 2013 IETF Trust and the persons identified as
authors of the code.  All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject
to the license terms contained in, the Simplified BSD License
set forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(http://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC 6991; see
the RFC itself for full legal notices.
  """
  _pyangbind_elements = {}

  

class yc_supporting_network_ietf_network__networks_network_supporting_network(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-network - based on the path /networks/network/supporting-network. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An underlay network, used to represent layered network
topologies.
  """
  __slots__ = ('_path_helper', '_extmethods', '__network_ref',)

  _yang_name = 'supporting-network'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__network_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'networks', u'network', u'supporting-network']

  def _get_network_ref(self):
    """
    Getter method for network_ref, mapped from YANG variable /networks/network/supporting_network/network_ref (leafref)

    YANG Description: References the underlay network.
    """
    return self.__network_ref
      
  def _set_network_ref(self, v, load=False):
    """
    Setter method for network_ref, mapped from YANG variable /networks/network/supporting_network/network_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_ref() directly.

    YANG Description: References the underlay network.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="network-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='leafref', is_config=True)""",
        })

    self.__network_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_ref(self):
    self.__network_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='leafref', is_config=True)

  network_ref = __builtin__.property(_get_network_ref, _set_network_ref)


  _pyangbind_elements = OrderedDict([('network_ref', network_ref), ])


class yc_supporting_node_ietf_network__networks_network_node_supporting_node(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-network - based on the path /networks/network/node/supporting-node. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Represents another node that is in an underlay network
and that supports this node.  Used to represent layering
structure.
  """
  __slots__ = ('_path_helper', '_extmethods', '__network_ref','__node_ref',)

  _yang_name = 'supporting-node'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__node_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="node-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='leafref', is_config=True)
    self.__network_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'networks', u'network', u'node', u'supporting-node']

  def _get_network_ref(self):
    """
    Getter method for network_ref, mapped from YANG variable /networks/network/node/supporting_node/network_ref (leafref)

    YANG Description: References the underlay network of which the
underlay node is a part.
    """
    return self.__network_ref
      
  def _set_network_ref(self, v, load=False):
    """
    Setter method for network_ref, mapped from YANG variable /networks/network/node/supporting_node/network_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_ref() directly.

    YANG Description: References the underlay network of which the
underlay node is a part.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="network-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='leafref', is_config=True)""",
        })

    self.__network_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_ref(self):
    self.__network_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='leafref', is_config=True)


  def _get_node_ref(self):
    """
    Getter method for node_ref, mapped from YANG variable /networks/network/node/supporting_node/node_ref (leafref)

    YANG Description: References the underlay node itself.
    """
    return self.__node_ref
      
  def _set_node_ref(self, v, load=False):
    """
    Setter method for node_ref, mapped from YANG variable /networks/network/node/supporting_node/node_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_node_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_node_ref() directly.

    YANG Description: References the underlay node itself.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="node-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """node_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="node-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='leafref', is_config=True)""",
        })

    self.__node_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_node_ref(self):
    self.__node_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="node-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='leafref', is_config=True)

  network_ref = __builtin__.property(_get_network_ref, _set_network_ref)
  node_ref = __builtin__.property(_get_node_ref, _set_node_ref)


  _pyangbind_elements = OrderedDict([('network_ref', network_ref), ('node_ref', node_ref), ])


class yc_node_ietf_network__networks_network_node(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-network - based on the path /networks/network/node. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The inventory of nodes of this network.
  """
  __slots__ = ('_path_helper', '_extmethods', '__node_id','__supporting_node',)

  _yang_name = 'node'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__node_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="node-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='node-id', is_config=True)
    self.__supporting_node = YANGDynClass(base=YANGListType("network_ref node_ref",yc_supporting_node_ietf_network__networks_network_node_supporting_node, yang_name="supporting-node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-ref node-ref', extensions=None), is_container='list', yang_name="supporting-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'networks', u'network', u'node']

  def _get_node_id(self):
    """
    Getter method for node_id, mapped from YANG variable /networks/network/node/node_id (node-id)

    YANG Description: Uniquely identifies a node within the containing
network.
    """
    return self.__node_id
      
  def _set_node_id(self, v, load=False):
    """
    Setter method for node_id, mapped from YANG variable /networks/network/node/node_id (node-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_node_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_node_id() directly.

    YANG Description: Uniquely identifies a node within the containing
network.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="node-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='node-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """node_id must be of a type compatible with node-id""",
          'defined-type': "ietf-network:node-id",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="node-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='node-id', is_config=True)""",
        })

    self.__node_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_node_id(self):
    self.__node_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="node-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='node-id', is_config=True)


  def _get_supporting_node(self):
    """
    Getter method for supporting_node, mapped from YANG variable /networks/network/node/supporting_node (list)

    YANG Description: Represents another node that is in an underlay network
and that supports this node.  Used to represent layering
structure.
    """
    return self.__supporting_node
      
  def _set_supporting_node(self, v, load=False):
    """
    Setter method for supporting_node, mapped from YANG variable /networks/network/node/supporting_node (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supporting_node is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supporting_node() directly.

    YANG Description: Represents another node that is in an underlay network
and that supports this node.  Used to represent layering
structure.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("network_ref node_ref",yc_supporting_node_ietf_network__networks_network_node_supporting_node, yang_name="supporting-node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-ref node-ref', extensions=None), is_container='list', yang_name="supporting-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supporting_node must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("network_ref node_ref",yc_supporting_node_ietf_network__networks_network_node_supporting_node, yang_name="supporting-node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-ref node-ref', extensions=None), is_container='list', yang_name="supporting-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='list', is_config=True)""",
        })

    self.__supporting_node = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supporting_node(self):
    self.__supporting_node = YANGDynClass(base=YANGListType("network_ref node_ref",yc_supporting_node_ietf_network__networks_network_node_supporting_node, yang_name="supporting-node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-ref node-ref', extensions=None), is_container='list', yang_name="supporting-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='list', is_config=True)

  node_id = __builtin__.property(_get_node_id, _set_node_id)
  supporting_node = __builtin__.property(_get_supporting_node, _set_supporting_node)


  _pyangbind_elements = OrderedDict([('node_id', node_id), ('supporting_node', supporting_node), ])


class yc_network_ietf_network__networks_network(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-network - based on the path /networks/network. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Describes a network.
A network typically contains an inventory of nodes,
topological information (augmented through the
network-topology data model), and layering information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__network_id','__supporting_network','__node',)

  _yang_name = 'network'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__network_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='network-id', is_config=True)
    self.__node = YANGDynClass(base=YANGListType("node_id",yc_node_ietf_network__networks_network_node, yang_name="node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='node-id', extensions=None), is_container='list', yang_name="node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='list', is_config=True)
    self.__supporting_network = YANGDynClass(base=YANGListType("network_ref",yc_supporting_network_ietf_network__networks_network_supporting_network, yang_name="supporting-network", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-ref', extensions=None), is_container='list', yang_name="supporting-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'networks', u'network']

  def _get_network_id(self):
    """
    Getter method for network_id, mapped from YANG variable /networks/network/network_id (network-id)

    YANG Description: Identifies a network.
    """
    return self.__network_id
      
  def _set_network_id(self, v, load=False):
    """
    Setter method for network_id, mapped from YANG variable /networks/network/network_id (network-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_id() directly.

    YANG Description: Identifies a network.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="network-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='network-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_id must be of a type compatible with network-id""",
          'defined-type': "ietf-network:network-id",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='network-id', is_config=True)""",
        })

    self.__network_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_id(self):
    self.__network_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='network-id', is_config=True)


  def _get_supporting_network(self):
    """
    Getter method for supporting_network, mapped from YANG variable /networks/network/supporting_network (list)

    YANG Description: An underlay network, used to represent layered network
topologies.
    """
    return self.__supporting_network
      
  def _set_supporting_network(self, v, load=False):
    """
    Setter method for supporting_network, mapped from YANG variable /networks/network/supporting_network (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supporting_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supporting_network() directly.

    YANG Description: An underlay network, used to represent layered network
topologies.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("network_ref",yc_supporting_network_ietf_network__networks_network_supporting_network, yang_name="supporting-network", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-ref', extensions=None), is_container='list', yang_name="supporting-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supporting_network must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("network_ref",yc_supporting_network_ietf_network__networks_network_supporting_network, yang_name="supporting-network", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-ref', extensions=None), is_container='list', yang_name="supporting-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='list', is_config=True)""",
        })

    self.__supporting_network = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supporting_network(self):
    self.__supporting_network = YANGDynClass(base=YANGListType("network_ref",yc_supporting_network_ietf_network__networks_network_supporting_network, yang_name="supporting-network", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-ref', extensions=None), is_container='list', yang_name="supporting-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='list', is_config=True)


  def _get_node(self):
    """
    Getter method for node, mapped from YANG variable /networks/network/node (list)

    YANG Description: The inventory of nodes of this network.
    """
    return self.__node
      
  def _set_node(self, v, load=False):
    """
    Setter method for node, mapped from YANG variable /networks/network/node (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_node is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_node() directly.

    YANG Description: The inventory of nodes of this network.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("node_id",yc_node_ietf_network__networks_network_node, yang_name="node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='node-id', extensions=None), is_container='list', yang_name="node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """node must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("node_id",yc_node_ietf_network__networks_network_node, yang_name="node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='node-id', extensions=None), is_container='list', yang_name="node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='list', is_config=True)""",
        })

    self.__node = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_node(self):
    self.__node = YANGDynClass(base=YANGListType("node_id",yc_node_ietf_network__networks_network_node, yang_name="node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='node-id', extensions=None), is_container='list', yang_name="node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='list', is_config=True)

  network_id = __builtin__.property(_get_network_id, _set_network_id)
  supporting_network = __builtin__.property(_get_supporting_network, _set_supporting_network)
  node = __builtin__.property(_get_node, _set_node)


  _pyangbind_elements = OrderedDict([('network_id', network_id), ('supporting_network', supporting_network), ('node', node), ])


class yc_networks_ietf_network__networks(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-network - based on the path /networks. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Serves as a top-level container for a list of networks.
  """
  __slots__ = ('_path_helper', '_extmethods', '__network',)

  _yang_name = 'networks'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__network = YANGDynClass(base=YANGListType("network_id",yc_network_ietf_network__networks_network, yang_name="network", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-id', extensions=None), is_container='list', yang_name="network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'networks']

  def _get_network(self):
    """
    Getter method for network, mapped from YANG variable /networks/network (list)

    YANG Description: Describes a network.
A network typically contains an inventory of nodes,
topological information (augmented through the
network-topology data model), and layering information.
    """
    return self.__network
      
  def _set_network(self, v, load=False):
    """
    Setter method for network, mapped from YANG variable /networks/network (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network() directly.

    YANG Description: Describes a network.
A network typically contains an inventory of nodes,
topological information (augmented through the
network-topology data model), and layering information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("network_id",yc_network_ietf_network__networks_network, yang_name="network", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-id', extensions=None), is_container='list', yang_name="network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("network_id",yc_network_ietf_network__networks_network, yang_name="network", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-id', extensions=None), is_container='list', yang_name="network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='list', is_config=True)""",
        })

    self.__network = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network(self):
    self.__network = YANGDynClass(base=YANGListType("network_id",yc_network_ietf_network__networks_network, yang_name="network", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-id', extensions=None), is_container='list', yang_name="network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='list', is_config=True)

  network = __builtin__.property(_get_network, _set_network)


  _pyangbind_elements = OrderedDict([('network', network), ])


class ietf_network(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-network - based on the path /ietf-network. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines a common base data model for a collection
of nodes in a network.  Node definitions are further used
in network topologies and inventories.

Copyright (c) 2018 IETF Trust and the persons identified as
authors of the code.  All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject
to the license terms contained in, the Simplified BSD License
set forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(https://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC 8345;
see the RFC itself for full legal notices.
  """
  __slots__ = ('_path_helper', '_extmethods', '__networks',)

  _yang_name = 'ietf-network'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__networks = YANGDynClass(base=yc_networks_ietf_network__networks, is_container='container', yang_name="networks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_networks(self):
    """
    Getter method for networks, mapped from YANG variable /networks (container)

    YANG Description: Serves as a top-level container for a list of networks.
    """
    return self.__networks
      
  def _set_networks(self, v, load=False):
    """
    Setter method for networks, mapped from YANG variable /networks (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_networks is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_networks() directly.

    YANG Description: Serves as a top-level container for a list of networks.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_networks_ietf_network__networks, is_container='container', yang_name="networks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """networks must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_networks_ietf_network__networks, is_container='container', yang_name="networks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='container', is_config=True)""",
        })

    self.__networks = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_networks(self):
    self.__networks = YANGDynClass(base=yc_networks_ietf_network__networks, is_container='container', yang_name="networks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='container', is_config=True)

  networks = __builtin__.property(_get_networks, _set_networks)


  _pyangbind_elements = OrderedDict([('networks', networks), ])


