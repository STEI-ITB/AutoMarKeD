# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_sensor_path_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_sensor_groups_sensor_group_sensor_paths_sensor_path(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-telemetry-model-driven-cfg - based on the path /telemetry-model-driven/sensor-groups/sensor-group/sensor-paths/sensor-path. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Sensor path configuration
  """
  __slots__ = ('_path_helper', '_extmethods', '__telemetry_sensor_path',)

  _yang_name = 'sensor-path'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__telemetry_sensor_path = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="telemetry-sensor-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['telemetry-model-driven', 'sensor-groups', 'sensor-group', 'sensor-paths', 'sensor-path']

  def _get_telemetry_sensor_path(self):
    """
    Getter method for telemetry_sensor_path, mapped from YANG variable /telemetry_model_driven/sensor_groups/sensor_group/sensor_paths/sensor_path/telemetry_sensor_path (string)

    YANG Description: Sensor Path
    """
    return self.__telemetry_sensor_path
      
  def _set_telemetry_sensor_path(self, v, load=False):
    """
    Setter method for telemetry_sensor_path, mapped from YANG variable /telemetry_model_driven/sensor_groups/sensor_group/sensor_paths/sensor_path/telemetry_sensor_path (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_telemetry_sensor_path is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_telemetry_sensor_path() directly.

    YANG Description: Sensor Path
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="telemetry-sensor-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """telemetry_sensor_path must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="telemetry-sensor-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='string', is_config=True)""",
        })

    self.__telemetry_sensor_path = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_telemetry_sensor_path(self):
    self.__telemetry_sensor_path = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="telemetry-sensor-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='string', is_config=True)

  telemetry_sensor_path = __builtin__.property(_get_telemetry_sensor_path, _set_telemetry_sensor_path)


  _pyangbind_elements = OrderedDict([('telemetry_sensor_path', telemetry_sensor_path), ])


class yc_sensor_paths_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_sensor_groups_sensor_group_sensor_paths(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-telemetry-model-driven-cfg - based on the path /telemetry-model-driven/sensor-groups/sensor-group/sensor-paths. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Sensor path configuration
  """
  __slots__ = ('_path_helper', '_extmethods', '__sensor_path',)

  _yang_name = 'sensor-paths'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__sensor_path = YANGDynClass(base=YANGListType("telemetry_sensor_path",yc_sensor_path_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_sensor_groups_sensor_group_sensor_paths_sensor_path, yang_name="sensor-path", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='telemetry-sensor-path', extensions=None), is_container='list', yang_name="sensor-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['telemetry-model-driven', 'sensor-groups', 'sensor-group', 'sensor-paths']

  def _get_sensor_path(self):
    """
    Getter method for sensor_path, mapped from YANG variable /telemetry_model_driven/sensor_groups/sensor_group/sensor_paths/sensor_path (list)

    YANG Description: Sensor path configuration
    """
    return self.__sensor_path
      
  def _set_sensor_path(self, v, load=False):
    """
    Setter method for sensor_path, mapped from YANG variable /telemetry_model_driven/sensor_groups/sensor_group/sensor_paths/sensor_path (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sensor_path is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sensor_path() directly.

    YANG Description: Sensor path configuration
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("telemetry_sensor_path",yc_sensor_path_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_sensor_groups_sensor_group_sensor_paths_sensor_path, yang_name="sensor-path", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='telemetry-sensor-path', extensions=None), is_container='list', yang_name="sensor-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sensor_path must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("telemetry_sensor_path",yc_sensor_path_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_sensor_groups_sensor_group_sensor_paths_sensor_path, yang_name="sensor-path", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='telemetry-sensor-path', extensions=None), is_container='list', yang_name="sensor-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='list', is_config=True)""",
        })

    self.__sensor_path = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sensor_path(self):
    self.__sensor_path = YANGDynClass(base=YANGListType("telemetry_sensor_path",yc_sensor_path_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_sensor_groups_sensor_group_sensor_paths_sensor_path, yang_name="sensor-path", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='telemetry-sensor-path', extensions=None), is_container='list', yang_name="sensor-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='list', is_config=True)

  sensor_path = __builtin__.property(_get_sensor_path, _set_sensor_path)


  _pyangbind_elements = OrderedDict([('sensor_path', sensor_path), ])


class yc_sensor_group_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_sensor_groups_sensor_group(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-telemetry-model-driven-cfg - based on the path /telemetry-model-driven/sensor-groups/sensor-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Sensor group configuration
  """
  __slots__ = ('_path_helper', '_extmethods', '__sensor_paths','__sensor_group_identifier',)

  _yang_name = 'sensor-group'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__sensor_paths = YANGDynClass(base=yc_sensor_paths_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_sensor_groups_sensor_group_sensor_paths, is_container='container', yang_name="sensor-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)
    self.__sensor_group_identifier = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[\\w\\-\\.:,_@#%$\\+=\\|;]+'}), is_leaf=True, yang_name="sensor-group-identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='xr:Cisco-ios-xr-string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['telemetry-model-driven', 'sensor-groups', 'sensor-group']

  def _get_sensor_paths(self):
    """
    Getter method for sensor_paths, mapped from YANG variable /telemetry_model_driven/sensor_groups/sensor_group/sensor_paths (container)

    YANG Description: Sensor path configuration
    """
    return self.__sensor_paths
      
  def _set_sensor_paths(self, v, load=False):
    """
    Setter method for sensor_paths, mapped from YANG variable /telemetry_model_driven/sensor_groups/sensor_group/sensor_paths (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sensor_paths is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sensor_paths() directly.

    YANG Description: Sensor path configuration
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_sensor_paths_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_sensor_groups_sensor_group_sensor_paths, is_container='container', yang_name="sensor-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sensor_paths must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_sensor_paths_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_sensor_groups_sensor_group_sensor_paths, is_container='container', yang_name="sensor-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)""",
        })

    self.__sensor_paths = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sensor_paths(self):
    self.__sensor_paths = YANGDynClass(base=yc_sensor_paths_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_sensor_groups_sensor_group_sensor_paths, is_container='container', yang_name="sensor-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)


  def _get_sensor_group_identifier(self):
    """
    Getter method for sensor_group_identifier, mapped from YANG variable /telemetry_model_driven/sensor_groups/sensor_group/sensor_group_identifier (xr:Cisco-ios-xr-string)

    YANG Description: The identifier for this group
    """
    return self.__sensor_group_identifier
      
  def _set_sensor_group_identifier(self, v, load=False):
    """
    Setter method for sensor_group_identifier, mapped from YANG variable /telemetry_model_driven/sensor_groups/sensor_group/sensor_group_identifier (xr:Cisco-ios-xr-string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sensor_group_identifier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sensor_group_identifier() directly.

    YANG Description: The identifier for this group
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[\\w\\-\\.:,_@#%$\\+=\\|;]+'}), is_leaf=True, yang_name="sensor-group-identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='xr:Cisco-ios-xr-string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sensor_group_identifier must be of a type compatible with xr:Cisco-ios-xr-string""",
          'defined-type': "xr:Cisco-ios-xr-string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[\\w\\-\\.:,_@#%$\\+=\\|;]+'}), is_leaf=True, yang_name="sensor-group-identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='xr:Cisco-ios-xr-string', is_config=True)""",
        })

    self.__sensor_group_identifier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sensor_group_identifier(self):
    self.__sensor_group_identifier = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[\\w\\-\\.:,_@#%$\\+=\\|;]+'}), is_leaf=True, yang_name="sensor-group-identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='xr:Cisco-ios-xr-string', is_config=True)

  sensor_paths = __builtin__.property(_get_sensor_paths, _set_sensor_paths)
  sensor_group_identifier = __builtin__.property(_get_sensor_group_identifier, _set_sensor_group_identifier)


  _pyangbind_elements = OrderedDict([('sensor_paths', sensor_paths), ('sensor_group_identifier', sensor_group_identifier), ])


class yc_sensor_groups_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_sensor_groups(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-telemetry-model-driven-cfg - based on the path /telemetry-model-driven/sensor-groups. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Sensor group configuration
  """
  __slots__ = ('_path_helper', '_extmethods', '__sensor_group',)

  _yang_name = 'sensor-groups'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__sensor_group = YANGDynClass(base=YANGListType("sensor_group_identifier",yc_sensor_group_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_sensor_groups_sensor_group, yang_name="sensor-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='sensor-group-identifier', extensions=None), is_container='list', yang_name="sensor-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['telemetry-model-driven', 'sensor-groups']

  def _get_sensor_group(self):
    """
    Getter method for sensor_group, mapped from YANG variable /telemetry_model_driven/sensor_groups/sensor_group (list)

    YANG Description: Sensor group configuration
    """
    return self.__sensor_group
      
  def _set_sensor_group(self, v, load=False):
    """
    Setter method for sensor_group, mapped from YANG variable /telemetry_model_driven/sensor_groups/sensor_group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sensor_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sensor_group() directly.

    YANG Description: Sensor group configuration
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("sensor_group_identifier",yc_sensor_group_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_sensor_groups_sensor_group, yang_name="sensor-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='sensor-group-identifier', extensions=None), is_container='list', yang_name="sensor-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sensor_group must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("sensor_group_identifier",yc_sensor_group_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_sensor_groups_sensor_group, yang_name="sensor-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='sensor-group-identifier', extensions=None), is_container='list', yang_name="sensor-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='list', is_config=True)""",
        })

    self.__sensor_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sensor_group(self):
    self.__sensor_group = YANGDynClass(base=YANGListType("sensor_group_identifier",yc_sensor_group_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_sensor_groups_sensor_group, yang_name="sensor-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='sensor-group-identifier', extensions=None), is_container='list', yang_name="sensor-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='list', is_config=True)

  sensor_group = __builtin__.property(_get_sensor_group, _set_sensor_group)


  _pyangbind_elements = OrderedDict([('sensor_group', sensor_group), ])


class yc_sensor_profile_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_subscriptions_subscription_sensor_profiles_sensor_profile(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-telemetry-model-driven-cfg - based on the path /telemetry-model-driven/subscriptions/subscription/sensor-profiles/sensor-profile. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Associate Sensor Group with Subscription
  """
  __slots__ = ('_path_helper', '_extmethods', '__strict_timer','__sample_interval','__sensorgroupid',)

  _yang_name = 'sensor-profile'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__strict_timer = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="strict-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='empty', is_config=True)
    self.__sample_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="sample-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='uint32', is_config=True)
    self.__sensorgroupid = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[\\w\\-\\.:,_@#%$\\+=\\|;]+'}), is_leaf=True, yang_name="sensorgroupid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='xr:Cisco-ios-xr-string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['telemetry-model-driven', 'subscriptions', 'subscription', 'sensor-profiles', 'sensor-profile']

  def _get_strict_timer(self):
    """
    Getter method for strict_timer, mapped from YANG variable /telemetry_model_driven/subscriptions/subscription/sensor_profiles/sensor_profile/strict_timer (empty)

    YANG Description: use strict timer
    """
    return self.__strict_timer
      
  def _set_strict_timer(self, v, load=False):
    """
    Setter method for strict_timer, mapped from YANG variable /telemetry_model_driven/subscriptions/subscription/sensor_profiles/sensor_profile/strict_timer (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_strict_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_strict_timer() directly.

    YANG Description: use strict timer
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="strict-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """strict_timer must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="strict-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='empty', is_config=True)""",
        })

    self.__strict_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_strict_timer(self):
    self.__strict_timer = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="strict-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='empty', is_config=True)


  def _get_sample_interval(self):
    """
    Getter method for sample_interval, mapped from YANG variable /telemetry_model_driven/subscriptions/subscription/sensor_profiles/sensor_profile/sample_interval (uint32)

    YANG Description: Sample interval in milliseconds
    """
    return self.__sample_interval
      
  def _set_sample_interval(self, v, load=False):
    """
    Setter method for sample_interval, mapped from YANG variable /telemetry_model_driven/subscriptions/subscription/sensor_profiles/sensor_profile/sample_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sample_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sample_interval() directly.

    YANG Description: Sample interval in milliseconds
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="sample-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sample_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="sample-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__sample_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sample_interval(self):
    self.__sample_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="sample-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='uint32', is_config=True)


  def _get_sensorgroupid(self):
    """
    Getter method for sensorgroupid, mapped from YANG variable /telemetry_model_driven/subscriptions/subscription/sensor_profiles/sensor_profile/sensorgroupid (xr:Cisco-ios-xr-string)

    YANG Description: Reference to the telemetry sensor group name
    """
    return self.__sensorgroupid
      
  def _set_sensorgroupid(self, v, load=False):
    """
    Setter method for sensorgroupid, mapped from YANG variable /telemetry_model_driven/subscriptions/subscription/sensor_profiles/sensor_profile/sensorgroupid (xr:Cisco-ios-xr-string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sensorgroupid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sensorgroupid() directly.

    YANG Description: Reference to the telemetry sensor group name
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[\\w\\-\\.:,_@#%$\\+=\\|;]+'}), is_leaf=True, yang_name="sensorgroupid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='xr:Cisco-ios-xr-string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sensorgroupid must be of a type compatible with xr:Cisco-ios-xr-string""",
          'defined-type': "xr:Cisco-ios-xr-string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[\\w\\-\\.:,_@#%$\\+=\\|;]+'}), is_leaf=True, yang_name="sensorgroupid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='xr:Cisco-ios-xr-string', is_config=True)""",
        })

    self.__sensorgroupid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sensorgroupid(self):
    self.__sensorgroupid = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[\\w\\-\\.:,_@#%$\\+=\\|;]+'}), is_leaf=True, yang_name="sensorgroupid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='xr:Cisco-ios-xr-string', is_config=True)

  strict_timer = __builtin__.property(_get_strict_timer, _set_strict_timer)
  sample_interval = __builtin__.property(_get_sample_interval, _set_sample_interval)
  sensorgroupid = __builtin__.property(_get_sensorgroupid, _set_sensorgroupid)


  _pyangbind_elements = OrderedDict([('strict_timer', strict_timer), ('sample_interval', sample_interval), ('sensorgroupid', sensorgroupid), ])


class yc_sensor_profiles_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_subscriptions_subscription_sensor_profiles(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-telemetry-model-driven-cfg - based on the path /telemetry-model-driven/subscriptions/subscription/sensor-profiles. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Associate Sensor Groups with Subscription
  """
  __slots__ = ('_path_helper', '_extmethods', '__sensor_profile',)

  _yang_name = 'sensor-profiles'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__sensor_profile = YANGDynClass(base=YANGListType("sensorgroupid",yc_sensor_profile_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_subscriptions_subscription_sensor_profiles_sensor_profile, yang_name="sensor-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='sensorgroupid', extensions=None), is_container='list', yang_name="sensor-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['telemetry-model-driven', 'subscriptions', 'subscription', 'sensor-profiles']

  def _get_sensor_profile(self):
    """
    Getter method for sensor_profile, mapped from YANG variable /telemetry_model_driven/subscriptions/subscription/sensor_profiles/sensor_profile (list)

    YANG Description: Associate Sensor Group with Subscription
    """
    return self.__sensor_profile
      
  def _set_sensor_profile(self, v, load=False):
    """
    Setter method for sensor_profile, mapped from YANG variable /telemetry_model_driven/subscriptions/subscription/sensor_profiles/sensor_profile (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sensor_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sensor_profile() directly.

    YANG Description: Associate Sensor Group with Subscription
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("sensorgroupid",yc_sensor_profile_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_subscriptions_subscription_sensor_profiles_sensor_profile, yang_name="sensor-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='sensorgroupid', extensions=None), is_container='list', yang_name="sensor-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sensor_profile must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("sensorgroupid",yc_sensor_profile_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_subscriptions_subscription_sensor_profiles_sensor_profile, yang_name="sensor-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='sensorgroupid', extensions=None), is_container='list', yang_name="sensor-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='list', is_config=True)""",
        })

    self.__sensor_profile = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sensor_profile(self):
    self.__sensor_profile = YANGDynClass(base=YANGListType("sensorgroupid",yc_sensor_profile_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_subscriptions_subscription_sensor_profiles_sensor_profile, yang_name="sensor-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='sensorgroupid', extensions=None), is_container='list', yang_name="sensor-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='list', is_config=True)

  sensor_profile = __builtin__.property(_get_sensor_profile, _set_sensor_profile)


  _pyangbind_elements = OrderedDict([('sensor_profile', sensor_profile), ])


class yc_destination_profile_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_subscriptions_subscription_destination_profiles_destination_profile(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-telemetry-model-driven-cfg - based on the path /telemetry-model-driven/subscriptions/subscription/destination-profiles/destination-profile. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Associate Destination Group with Subscription
  """
  __slots__ = ('_path_helper', '_extmethods', '__destination_id',)

  _yang_name = 'destination-profile'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__destination_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[\\w\\-\\.:,_@#%$\\+=\\|;]+'}), is_leaf=True, yang_name="destination-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='xr:Cisco-ios-xr-string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['telemetry-model-driven', 'subscriptions', 'subscription', 'destination-profiles', 'destination-profile']

  def _get_destination_id(self):
    """
    Getter method for destination_id, mapped from YANG variable /telemetry_model_driven/subscriptions/subscription/destination_profiles/destination_profile/destination_id (xr:Cisco-ios-xr-string)

    YANG Description: Destination Id to associate with
Subscription
    """
    return self.__destination_id
      
  def _set_destination_id(self, v, load=False):
    """
    Setter method for destination_id, mapped from YANG variable /telemetry_model_driven/subscriptions/subscription/destination_profiles/destination_profile/destination_id (xr:Cisco-ios-xr-string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_id() directly.

    YANG Description: Destination Id to associate with
Subscription
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[\\w\\-\\.:,_@#%$\\+=\\|;]+'}), is_leaf=True, yang_name="destination-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='xr:Cisco-ios-xr-string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination_id must be of a type compatible with xr:Cisco-ios-xr-string""",
          'defined-type': "xr:Cisco-ios-xr-string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[\\w\\-\\.:,_@#%$\\+=\\|;]+'}), is_leaf=True, yang_name="destination-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='xr:Cisco-ios-xr-string', is_config=True)""",
        })

    self.__destination_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination_id(self):
    self.__destination_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[\\w\\-\\.:,_@#%$\\+=\\|;]+'}), is_leaf=True, yang_name="destination-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='xr:Cisco-ios-xr-string', is_config=True)

  destination_id = __builtin__.property(_get_destination_id, _set_destination_id)


  _pyangbind_elements = OrderedDict([('destination_id', destination_id), ])


class yc_destination_profiles_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_subscriptions_subscription_destination_profiles(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-telemetry-model-driven-cfg - based on the path /telemetry-model-driven/subscriptions/subscription/destination-profiles. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Associate Destination Groups with Subscription
  """
  __slots__ = ('_path_helper', '_extmethods', '__destination_profile',)

  _yang_name = 'destination-profiles'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__destination_profile = YANGDynClass(base=YANGListType("destination_id",yc_destination_profile_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_subscriptions_subscription_destination_profiles_destination_profile, yang_name="destination-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='destination-id', extensions=None), is_container='list', yang_name="destination-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['telemetry-model-driven', 'subscriptions', 'subscription', 'destination-profiles']

  def _get_destination_profile(self):
    """
    Getter method for destination_profile, mapped from YANG variable /telemetry_model_driven/subscriptions/subscription/destination_profiles/destination_profile (list)

    YANG Description: Associate Destination Group with Subscription
    """
    return self.__destination_profile
      
  def _set_destination_profile(self, v, load=False):
    """
    Setter method for destination_profile, mapped from YANG variable /telemetry_model_driven/subscriptions/subscription/destination_profiles/destination_profile (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_profile() directly.

    YANG Description: Associate Destination Group with Subscription
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("destination_id",yc_destination_profile_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_subscriptions_subscription_destination_profiles_destination_profile, yang_name="destination-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='destination-id', extensions=None), is_container='list', yang_name="destination-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination_profile must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("destination_id",yc_destination_profile_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_subscriptions_subscription_destination_profiles_destination_profile, yang_name="destination-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='destination-id', extensions=None), is_container='list', yang_name="destination-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='list', is_config=True)""",
        })

    self.__destination_profile = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination_profile(self):
    self.__destination_profile = YANGDynClass(base=YANGListType("destination_id",yc_destination_profile_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_subscriptions_subscription_destination_profiles_destination_profile, yang_name="destination-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='destination-id', extensions=None), is_container='list', yang_name="destination-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='list', is_config=True)

  destination_profile = __builtin__.property(_get_destination_profile, _set_destination_profile)


  _pyangbind_elements = OrderedDict([('destination_profile', destination_profile), ])


class yc_subscription_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_subscriptions_subscription(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-telemetry-model-driven-cfg - based on the path /telemetry-model-driven/subscriptions/subscription. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Streaming Telemetry Subscription
  """
  __slots__ = ('_path_helper', '_extmethods', '__sensor_profiles','__destination_profiles','__source_qos_marking','__source_interface','__subscription_identifier',)

  _yang_name = 'subscription'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__sensor_profiles = YANGDynClass(base=yc_sensor_profiles_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_subscriptions_subscription_sensor_profiles, is_container='container', yang_name="sensor-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)
    self.__destination_profiles = YANGDynClass(base=yc_destination_profiles_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_subscriptions_subscription_destination_profiles, is_container='container', yang_name="destination-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)
    self.__source_qos_marking = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {'value': 0}, 'cs1': {'value': 8}, 'af11': {'value': 10}, 'af12': {'value': 12}, 'af13': {'value': 14}, 'cs2': {'value': 16}, 'af21': {'value': 18}, 'af22': {'value': 20}, 'af23': {'value': 22}, 'cs3': {'value': 24}, 'af31': {'value': 26}, 'af32': {'value': 28}, 'af33': {'value': 30}, 'cs4': {'value': 32}, 'af41': {'value': 34}, 'af42': {'value': 36}, 'af43': {'value': 38}, 'cs5': {'value': 40}, 'ef': {'value': 46}, 'cs6': {'value': 48}, 'cs7': {'value': 56}},), is_leaf=True, yang_name="source-qos-marking", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='Mdt-dscp-value', is_config=True)
    self.__source_interface = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z0-9._/-]+'}), is_leaf=True, yang_name="source-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='xr:Interface-name', is_config=True)
    self.__subscription_identifier = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[\\w\\-\\.:,_@#%$\\+=\\|;]+'}), is_leaf=True, yang_name="subscription-identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='xr:Cisco-ios-xr-string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['telemetry-model-driven', 'subscriptions', 'subscription']

  def _get_sensor_profiles(self):
    """
    Getter method for sensor_profiles, mapped from YANG variable /telemetry_model_driven/subscriptions/subscription/sensor_profiles (container)

    YANG Description: Associate Sensor Groups with Subscription
    """
    return self.__sensor_profiles
      
  def _set_sensor_profiles(self, v, load=False):
    """
    Setter method for sensor_profiles, mapped from YANG variable /telemetry_model_driven/subscriptions/subscription/sensor_profiles (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sensor_profiles is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sensor_profiles() directly.

    YANG Description: Associate Sensor Groups with Subscription
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_sensor_profiles_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_subscriptions_subscription_sensor_profiles, is_container='container', yang_name="sensor-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sensor_profiles must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_sensor_profiles_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_subscriptions_subscription_sensor_profiles, is_container='container', yang_name="sensor-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)""",
        })

    self.__sensor_profiles = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sensor_profiles(self):
    self.__sensor_profiles = YANGDynClass(base=yc_sensor_profiles_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_subscriptions_subscription_sensor_profiles, is_container='container', yang_name="sensor-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)


  def _get_destination_profiles(self):
    """
    Getter method for destination_profiles, mapped from YANG variable /telemetry_model_driven/subscriptions/subscription/destination_profiles (container)

    YANG Description: Associate Destination Groups with Subscription
    """
    return self.__destination_profiles
      
  def _set_destination_profiles(self, v, load=False):
    """
    Setter method for destination_profiles, mapped from YANG variable /telemetry_model_driven/subscriptions/subscription/destination_profiles (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_profiles is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_profiles() directly.

    YANG Description: Associate Destination Groups with Subscription
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_destination_profiles_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_subscriptions_subscription_destination_profiles, is_container='container', yang_name="destination-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination_profiles must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_destination_profiles_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_subscriptions_subscription_destination_profiles, is_container='container', yang_name="destination-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)""",
        })

    self.__destination_profiles = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination_profiles(self):
    self.__destination_profiles = YANGDynClass(base=yc_destination_profiles_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_subscriptions_subscription_destination_profiles, is_container='container', yang_name="destination-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)


  def _get_source_qos_marking(self):
    """
    Getter method for source_qos_marking, mapped from YANG variable /telemetry_model_driven/subscriptions/subscription/source_qos_marking (Mdt-dscp-value)

    YANG Description: Outgoing DSCP value
    """
    return self.__source_qos_marking
      
  def _set_source_qos_marking(self, v, load=False):
    """
    Setter method for source_qos_marking, mapped from YANG variable /telemetry_model_driven/subscriptions/subscription/source_qos_marking (Mdt-dscp-value)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_qos_marking is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_qos_marking() directly.

    YANG Description: Outgoing DSCP value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {'value': 0}, 'cs1': {'value': 8}, 'af11': {'value': 10}, 'af12': {'value': 12}, 'af13': {'value': 14}, 'cs2': {'value': 16}, 'af21': {'value': 18}, 'af22': {'value': 20}, 'af23': {'value': 22}, 'cs3': {'value': 24}, 'af31': {'value': 26}, 'af32': {'value': 28}, 'af33': {'value': 30}, 'cs4': {'value': 32}, 'af41': {'value': 34}, 'af42': {'value': 36}, 'af43': {'value': 38}, 'cs5': {'value': 40}, 'ef': {'value': 46}, 'cs6': {'value': 48}, 'cs7': {'value': 56}},), is_leaf=True, yang_name="source-qos-marking", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='Mdt-dscp-value', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_qos_marking must be of a type compatible with Mdt-dscp-value""",
          'defined-type': "Cisco-IOS-XR-telemetry-model-driven-cfg:Mdt-dscp-value",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {'value': 0}, 'cs1': {'value': 8}, 'af11': {'value': 10}, 'af12': {'value': 12}, 'af13': {'value': 14}, 'cs2': {'value': 16}, 'af21': {'value': 18}, 'af22': {'value': 20}, 'af23': {'value': 22}, 'cs3': {'value': 24}, 'af31': {'value': 26}, 'af32': {'value': 28}, 'af33': {'value': 30}, 'cs4': {'value': 32}, 'af41': {'value': 34}, 'af42': {'value': 36}, 'af43': {'value': 38}, 'cs5': {'value': 40}, 'ef': {'value': 46}, 'cs6': {'value': 48}, 'cs7': {'value': 56}},), is_leaf=True, yang_name="source-qos-marking", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='Mdt-dscp-value', is_config=True)""",
        })

    self.__source_qos_marking = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_qos_marking(self):
    self.__source_qos_marking = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {'value': 0}, 'cs1': {'value': 8}, 'af11': {'value': 10}, 'af12': {'value': 12}, 'af13': {'value': 14}, 'cs2': {'value': 16}, 'af21': {'value': 18}, 'af22': {'value': 20}, 'af23': {'value': 22}, 'cs3': {'value': 24}, 'af31': {'value': 26}, 'af32': {'value': 28}, 'af33': {'value': 30}, 'cs4': {'value': 32}, 'af41': {'value': 34}, 'af42': {'value': 36}, 'af43': {'value': 38}, 'cs5': {'value': 40}, 'ef': {'value': 46}, 'cs6': {'value': 48}, 'cs7': {'value': 56}},), is_leaf=True, yang_name="source-qos-marking", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='Mdt-dscp-value', is_config=True)


  def _get_source_interface(self):
    """
    Getter method for source_interface, mapped from YANG variable /telemetry_model_driven/subscriptions/subscription/source_interface (xr:Interface-name)

    YANG Description: Source address to use for streaming telemetry
information
    """
    return self.__source_interface
      
  def _set_source_interface(self, v, load=False):
    """
    Setter method for source_interface, mapped from YANG variable /telemetry_model_driven/subscriptions/subscription/source_interface (xr:Interface-name)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_interface() directly.

    YANG Description: Source address to use for streaming telemetry
information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z0-9._/-]+'}), is_leaf=True, yang_name="source-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='xr:Interface-name', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_interface must be of a type compatible with xr:Interface-name""",
          'defined-type': "xr:Interface-name",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z0-9._/-]+'}), is_leaf=True, yang_name="source-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='xr:Interface-name', is_config=True)""",
        })

    self.__source_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_interface(self):
    self.__source_interface = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z0-9._/-]+'}), is_leaf=True, yang_name="source-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='xr:Interface-name', is_config=True)


  def _get_subscription_identifier(self):
    """
    Getter method for subscription_identifier, mapped from YANG variable /telemetry_model_driven/subscriptions/subscription/subscription_identifier (xr:Cisco-ios-xr-string)

    YANG Description: Subscription identifier string
    """
    return self.__subscription_identifier
      
  def _set_subscription_identifier(self, v, load=False):
    """
    Setter method for subscription_identifier, mapped from YANG variable /telemetry_model_driven/subscriptions/subscription/subscription_identifier (xr:Cisco-ios-xr-string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subscription_identifier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subscription_identifier() directly.

    YANG Description: Subscription identifier string
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[\\w\\-\\.:,_@#%$\\+=\\|;]+'}), is_leaf=True, yang_name="subscription-identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='xr:Cisco-ios-xr-string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subscription_identifier must be of a type compatible with xr:Cisco-ios-xr-string""",
          'defined-type': "xr:Cisco-ios-xr-string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[\\w\\-\\.:,_@#%$\\+=\\|;]+'}), is_leaf=True, yang_name="subscription-identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='xr:Cisco-ios-xr-string', is_config=True)""",
        })

    self.__subscription_identifier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subscription_identifier(self):
    self.__subscription_identifier = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[\\w\\-\\.:,_@#%$\\+=\\|;]+'}), is_leaf=True, yang_name="subscription-identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='xr:Cisco-ios-xr-string', is_config=True)

  sensor_profiles = __builtin__.property(_get_sensor_profiles, _set_sensor_profiles)
  destination_profiles = __builtin__.property(_get_destination_profiles, _set_destination_profiles)
  source_qos_marking = __builtin__.property(_get_source_qos_marking, _set_source_qos_marking)
  source_interface = __builtin__.property(_get_source_interface, _set_source_interface)
  subscription_identifier = __builtin__.property(_get_subscription_identifier, _set_subscription_identifier)


  _pyangbind_elements = OrderedDict([('sensor_profiles', sensor_profiles), ('destination_profiles', destination_profiles), ('source_qos_marking', source_qos_marking), ('source_interface', source_interface), ('subscription_identifier', subscription_identifier), ])


class yc_subscriptions_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_subscriptions(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-telemetry-model-driven-cfg - based on the path /telemetry-model-driven/subscriptions. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Streaming Telemetry Subscription
  """
  __slots__ = ('_path_helper', '_extmethods', '__subscription',)

  _yang_name = 'subscriptions'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__subscription = YANGDynClass(base=YANGListType("subscription_identifier",yc_subscription_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_subscriptions_subscription, yang_name="subscription", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='subscription-identifier', extensions=None), is_container='list', yang_name="subscription", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['telemetry-model-driven', 'subscriptions']

  def _get_subscription(self):
    """
    Getter method for subscription, mapped from YANG variable /telemetry_model_driven/subscriptions/subscription (list)

    YANG Description: Streaming Telemetry Subscription
    """
    return self.__subscription
      
  def _set_subscription(self, v, load=False):
    """
    Setter method for subscription, mapped from YANG variable /telemetry_model_driven/subscriptions/subscription (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subscription is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subscription() directly.

    YANG Description: Streaming Telemetry Subscription
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("subscription_identifier",yc_subscription_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_subscriptions_subscription, yang_name="subscription", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='subscription-identifier', extensions=None), is_container='list', yang_name="subscription", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subscription must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("subscription_identifier",yc_subscription_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_subscriptions_subscription, yang_name="subscription", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='subscription-identifier', extensions=None), is_container='list', yang_name="subscription", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='list', is_config=True)""",
        })

    self.__subscription = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subscription(self):
    self.__subscription = YANGDynClass(base=YANGListType("subscription_identifier",yc_subscription_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_subscriptions_subscription, yang_name="subscription", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='subscription-identifier', extensions=None), is_container='list', yang_name="subscription", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='list', is_config=True)

  subscription = __builtin__.property(_get_subscription, _set_subscription)


  _pyangbind_elements = OrderedDict([('subscription', subscription), ])


class yc_empty_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_include_empty(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-telemetry-model-driven-cfg - based on the path /telemetry-model-driven/include/empty. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Include fields with empty values in output.
  """
  __slots__ = ('_path_helper', '_extmethods', '__values',)

  _yang_name = 'empty'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__values = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="values", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='empty', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['telemetry-model-driven', 'include', 'empty']

  def _get_values(self):
    """
    Getter method for values, mapped from YANG variable /telemetry_model_driven/include/empty/values (empty)

    YANG Description: String type fields with empty string value,
for example, are omitted by default. This
provides an option to override this behavior
and include them in the output.
    """
    return self.__values
      
  def _set_values(self, v, load=False):
    """
    Setter method for values, mapped from YANG variable /telemetry_model_driven/include/empty/values (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_values is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_values() directly.

    YANG Description: String type fields with empty string value,
for example, are omitted by default. This
provides an option to override this behavior
and include them in the output.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="values", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """values must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="values", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='empty', is_config=True)""",
        })

    self.__values = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_values(self):
    self.__values = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="values", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='empty', is_config=True)

  values = __builtin__.property(_get_values, _set_values)


  _pyangbind_elements = OrderedDict([('values', values), ])


class yc_include_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_include(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-telemetry-model-driven-cfg - based on the path /telemetry-model-driven/include. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Include fields with empty values in output.
  """
  __slots__ = ('_path_helper', '_extmethods', '__empty',)

  _yang_name = 'include'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__empty = YANGDynClass(base=yc_empty_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_include_empty, is_container='container', yang_name="empty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['telemetry-model-driven', 'include']

  def _get_empty(self):
    """
    Getter method for empty, mapped from YANG variable /telemetry_model_driven/include/empty (container)

    YANG Description: Include fields with empty values in output.
    """
    return self.__empty
      
  def _set_empty(self, v, load=False):
    """
    Setter method for empty, mapped from YANG variable /telemetry_model_driven/include/empty (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_empty is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_empty() directly.

    YANG Description: Include fields with empty values in output.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_empty_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_include_empty, is_container='container', yang_name="empty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """empty must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_empty_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_include_empty, is_container='container', yang_name="empty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)""",
        })

    self.__empty = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_empty(self):
    self.__empty = YANGDynClass(base=yc_empty_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_include_empty, is_container='container', yang_name="empty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)

  empty = __builtin__.property(_get_empty, _set_empty)


  _pyangbind_elements = OrderedDict([('empty', empty), ])


class yc_protocol_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups_destination_group_ipv6_destinations_ipv6_destination_protocol(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-telemetry-model-driven-cfg - based on the path /telemetry-model-driven/destination-groups/destination-group/ipv6-destinations/ipv6-destination/protocol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Transport Protocol used to transmit telemetry
data to the collector
  """
  __slots__ = ('_path_helper', '_extmethods', '__protocol','__tls_hostname','__no_tls','__packetsize',)

  _yang_name = 'protocol'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'grpc': {'value': 1}, 'tcp': {'value': 2}, 'udp': {'value': 3}},), is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='Proto-type', is_config=True)
    self.__tls_hostname = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tls-hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='string', is_config=True)
    self.__no_tls = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="no-tls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='uint32', is_config=True)
    self.__packetsize = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['484..65507']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1472), is_leaf=True, yang_name="packetsize", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['telemetry-model-driven', 'destination-groups', 'destination-group', 'ipv6-destinations', 'ipv6-destination', 'protocol']

  def _get_protocol(self):
    """
    Getter method for protocol, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv6_destinations/ipv6_destination/protocol/protocol (Proto-type)

    YANG Description: protocol
    """
    return self.__protocol
      
  def _set_protocol(self, v, load=False):
    """
    Setter method for protocol, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv6_destinations/ipv6_destination/protocol/protocol (Proto-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol() directly.

    YANG Description: protocol
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'grpc': {'value': 1}, 'tcp': {'value': 2}, 'udp': {'value': 3}},), is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='Proto-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol must be of a type compatible with Proto-type""",
          'defined-type': "Cisco-IOS-XR-telemetry-model-driven-cfg:Proto-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'grpc': {'value': 1}, 'tcp': {'value': 2}, 'udp': {'value': 3}},), is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='Proto-type', is_config=True)""",
        })

    self.__protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol(self):
    self.__protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'grpc': {'value': 1}, 'tcp': {'value': 2}, 'udp': {'value': 3}},), is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='Proto-type', is_config=True)


  def _get_tls_hostname(self):
    """
    Getter method for tls_hostname, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv6_destinations/ipv6_destination/protocol/tls_hostname (string)

    YANG Description: tls hostname
    """
    return self.__tls_hostname
      
  def _set_tls_hostname(self, v, load=False):
    """
    Setter method for tls_hostname, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv6_destinations/ipv6_destination/protocol/tls_hostname (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tls_hostname is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tls_hostname() directly.

    YANG Description: tls hostname
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="tls-hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tls_hostname must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tls-hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='string', is_config=True)""",
        })

    self.__tls_hostname = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tls_hostname(self):
    self.__tls_hostname = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tls-hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='string', is_config=True)


  def _get_no_tls(self):
    """
    Getter method for no_tls, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv6_destinations/ipv6_destination/protocol/no_tls (uint32)

    YANG Description: no tls
    """
    return self.__no_tls
      
  def _set_no_tls(self, v, load=False):
    """
    Setter method for no_tls, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv6_destinations/ipv6_destination/protocol/no_tls (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_no_tls is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_no_tls() directly.

    YANG Description: no tls
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="no-tls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """no_tls must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="no-tls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__no_tls = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_no_tls(self):
    self.__no_tls = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="no-tls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='uint32', is_config=True)


  def _get_packetsize(self):
    """
    Getter method for packetsize, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv6_destinations/ipv6_destination/protocol/packetsize (uint32)

    YANG Description: udp packetsize
    """
    return self.__packetsize
      
  def _set_packetsize(self, v, load=False):
    """
    Setter method for packetsize, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv6_destinations/ipv6_destination/protocol/packetsize (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_packetsize is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_packetsize() directly.

    YANG Description: udp packetsize
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['484..65507']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1472), is_leaf=True, yang_name="packetsize", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """packetsize must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['484..65507']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1472), is_leaf=True, yang_name="packetsize", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__packetsize = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_packetsize(self):
    self.__packetsize = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['484..65507']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1472), is_leaf=True, yang_name="packetsize", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='uint32', is_config=True)

  protocol = __builtin__.property(_get_protocol, _set_protocol)
  tls_hostname = __builtin__.property(_get_tls_hostname, _set_tls_hostname)
  no_tls = __builtin__.property(_get_no_tls, _set_no_tls)
  packetsize = __builtin__.property(_get_packetsize, _set_packetsize)


  _pyangbind_elements = OrderedDict([('protocol', protocol), ('tls_hostname', tls_hostname), ('no_tls', no_tls), ('packetsize', packetsize), ])


class yc_ipv6_destination_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups_destination_group_ipv6_destinations_ipv6_destination(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-telemetry-model-driven-cfg - based on the path /telemetry-model-driven/destination-groups/destination-group/ipv6-destinations/ipv6-destination. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: destination IP address
  """
  __slots__ = ('_path_helper', '_extmethods', '__ipv6_address','__destination_port','__encoding','__protocol',)

  _yang_name = 'ipv6-destination'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='inet:ipv6-address-no-zone', is_config=True)
    self.__destination_port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="destination-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='xr:Cisco-ios-xr-port-number', is_config=True)
    self.__encoding = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'gpb': {'value': 2}, 'self-describing-gpb': {'value': 3}, 'json': {'value': 4}},), is_leaf=True, yang_name="encoding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='Encode-type', is_config=True)
    self.__protocol = YANGDynClass(base=yc_protocol_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups_destination_group_ipv6_destinations_ipv6_destination_protocol, is_container='container', yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['telemetry-model-driven', 'destination-groups', 'destination-group', 'ipv6-destinations', 'ipv6-destination']

  def _get_ipv6_address(self):
    """
    Getter method for ipv6_address, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv6_destinations/ipv6_destination/ipv6_address (inet:ipv6-address-no-zone)

    YANG Description: Destination IPv6 address
    """
    return self.__ipv6_address
      
  def _set_ipv6_address(self, v, load=False):
    """
    Setter method for ipv6_address, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv6_destinations/ipv6_destination/ipv6_address (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_address() directly.

    YANG Description: Destination IPv6 address
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='inet:ipv6-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_address must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='inet:ipv6-address-no-zone', is_config=True)""",
        })

    self.__ipv6_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_address(self):
    self.__ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='inet:ipv6-address-no-zone', is_config=True)


  def _get_destination_port(self):
    """
    Getter method for destination_port, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv6_destinations/ipv6_destination/destination_port (xr:Cisco-ios-xr-port-number)

    YANG Description: destination port
    """
    return self.__destination_port
      
  def _set_destination_port(self, v, load=False):
    """
    Setter method for destination_port, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv6_destinations/ipv6_destination/destination_port (xr:Cisco-ios-xr-port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_port() directly.

    YANG Description: destination port
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="destination-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='xr:Cisco-ios-xr-port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination_port must be of a type compatible with xr:Cisco-ios-xr-port-number""",
          'defined-type': "xr:Cisco-ios-xr-port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="destination-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='xr:Cisco-ios-xr-port-number', is_config=True)""",
        })

    self.__destination_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination_port(self):
    self.__destination_port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="destination-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='xr:Cisco-ios-xr-port-number', is_config=True)


  def _get_encoding(self):
    """
    Getter method for encoding, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv6_destinations/ipv6_destination/encoding (Encode-type)

    YANG Description: Encoding used to transmit telemetry data to the
collector
    """
    return self.__encoding
      
  def _set_encoding(self, v, load=False):
    """
    Setter method for encoding, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv6_destinations/ipv6_destination/encoding (Encode-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_encoding is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_encoding() directly.

    YANG Description: Encoding used to transmit telemetry data to the
collector
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'gpb': {'value': 2}, 'self-describing-gpb': {'value': 3}, 'json': {'value': 4}},), is_leaf=True, yang_name="encoding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='Encode-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """encoding must be of a type compatible with Encode-type""",
          'defined-type': "Cisco-IOS-XR-telemetry-model-driven-cfg:Encode-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'gpb': {'value': 2}, 'self-describing-gpb': {'value': 3}, 'json': {'value': 4}},), is_leaf=True, yang_name="encoding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='Encode-type', is_config=True)""",
        })

    self.__encoding = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_encoding(self):
    self.__encoding = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'gpb': {'value': 2}, 'self-describing-gpb': {'value': 3}, 'json': {'value': 4}},), is_leaf=True, yang_name="encoding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='Encode-type', is_config=True)


  def _get_protocol(self):
    """
    Getter method for protocol, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv6_destinations/ipv6_destination/protocol (container)

    YANG Description: Transport Protocol used to transmit telemetry
data to the collector
    """
    return self.__protocol
      
  def _set_protocol(self, v, load=False):
    """
    Setter method for protocol, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv6_destinations/ipv6_destination/protocol (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol() directly.

    YANG Description: Transport Protocol used to transmit telemetry
data to the collector
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_protocol_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups_destination_group_ipv6_destinations_ipv6_destination_protocol, is_container='container', yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_protocol_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups_destination_group_ipv6_destinations_ipv6_destination_protocol, is_container='container', yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)""",
        })

    self.__protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol(self):
    self.__protocol = YANGDynClass(base=yc_protocol_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups_destination_group_ipv6_destinations_ipv6_destination_protocol, is_container='container', yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)

  ipv6_address = __builtin__.property(_get_ipv6_address, _set_ipv6_address)
  destination_port = __builtin__.property(_get_destination_port, _set_destination_port)
  encoding = __builtin__.property(_get_encoding, _set_encoding)
  protocol = __builtin__.property(_get_protocol, _set_protocol)


  _pyangbind_elements = OrderedDict([('ipv6_address', ipv6_address), ('destination_port', destination_port), ('encoding', encoding), ('protocol', protocol), ])


class yc_ipv6_destinations_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups_destination_group_ipv6_destinations(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-telemetry-model-driven-cfg - based on the path /telemetry-model-driven/destination-groups/destination-group/ipv6-destinations. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Destination address configuration
  """
  __slots__ = ('_path_helper', '_extmethods', '__ipv6_destination',)

  _yang_name = 'ipv6-destinations'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ipv6_destination = YANGDynClass(base=YANGListType("ipv6_address destination_port",yc_ipv6_destination_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups_destination_group_ipv6_destinations_ipv6_destination, yang_name="ipv6-destination", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipv6-address destination-port', extensions=None), is_container='list', yang_name="ipv6-destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['telemetry-model-driven', 'destination-groups', 'destination-group', 'ipv6-destinations']

  def _get_ipv6_destination(self):
    """
    Getter method for ipv6_destination, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv6_destinations/ipv6_destination (list)

    YANG Description: destination IP address
    """
    return self.__ipv6_destination
      
  def _set_ipv6_destination(self, v, load=False):
    """
    Setter method for ipv6_destination, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv6_destinations/ipv6_destination (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_destination is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_destination() directly.

    YANG Description: destination IP address
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ipv6_address destination_port",yc_ipv6_destination_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups_destination_group_ipv6_destinations_ipv6_destination, yang_name="ipv6-destination", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipv6-address destination-port', extensions=None), is_container='list', yang_name="ipv6-destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_destination must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ipv6_address destination_port",yc_ipv6_destination_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups_destination_group_ipv6_destinations_ipv6_destination, yang_name="ipv6-destination", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipv6-address destination-port', extensions=None), is_container='list', yang_name="ipv6-destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='list', is_config=True)""",
        })

    self.__ipv6_destination = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_destination(self):
    self.__ipv6_destination = YANGDynClass(base=YANGListType("ipv6_address destination_port",yc_ipv6_destination_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups_destination_group_ipv6_destinations_ipv6_destination, yang_name="ipv6-destination", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipv6-address destination-port', extensions=None), is_container='list', yang_name="ipv6-destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='list', is_config=True)

  ipv6_destination = __builtin__.property(_get_ipv6_destination, _set_ipv6_destination)


  _pyangbind_elements = OrderedDict([('ipv6_destination', ipv6_destination), ])


class yc_protocol_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups_destination_group_ipv4_destinations_ipv4_destination_protocol(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-telemetry-model-driven-cfg - based on the path /telemetry-model-driven/destination-groups/destination-group/ipv4-destinations/ipv4-destination/protocol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Transport Protocol used to transmit telemetry
data to the collector
  """
  __slots__ = ('_path_helper', '_extmethods', '__protocol','__tls_hostname','__no_tls','__packetsize',)

  _yang_name = 'protocol'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'grpc': {'value': 1}, 'tcp': {'value': 2}, 'udp': {'value': 3}},), is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='Proto-type', is_config=True)
    self.__tls_hostname = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tls-hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='string', is_config=True)
    self.__no_tls = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="no-tls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='uint32', is_config=True)
    self.__packetsize = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['484..65507']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1472), is_leaf=True, yang_name="packetsize", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['telemetry-model-driven', 'destination-groups', 'destination-group', 'ipv4-destinations', 'ipv4-destination', 'protocol']

  def _get_protocol(self):
    """
    Getter method for protocol, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv4_destinations/ipv4_destination/protocol/protocol (Proto-type)

    YANG Description: protocol
    """
    return self.__protocol
      
  def _set_protocol(self, v, load=False):
    """
    Setter method for protocol, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv4_destinations/ipv4_destination/protocol/protocol (Proto-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol() directly.

    YANG Description: protocol
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'grpc': {'value': 1}, 'tcp': {'value': 2}, 'udp': {'value': 3}},), is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='Proto-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol must be of a type compatible with Proto-type""",
          'defined-type': "Cisco-IOS-XR-telemetry-model-driven-cfg:Proto-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'grpc': {'value': 1}, 'tcp': {'value': 2}, 'udp': {'value': 3}},), is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='Proto-type', is_config=True)""",
        })

    self.__protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol(self):
    self.__protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'grpc': {'value': 1}, 'tcp': {'value': 2}, 'udp': {'value': 3}},), is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='Proto-type', is_config=True)


  def _get_tls_hostname(self):
    """
    Getter method for tls_hostname, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv4_destinations/ipv4_destination/protocol/tls_hostname (string)

    YANG Description: tls hostname
    """
    return self.__tls_hostname
      
  def _set_tls_hostname(self, v, load=False):
    """
    Setter method for tls_hostname, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv4_destinations/ipv4_destination/protocol/tls_hostname (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tls_hostname is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tls_hostname() directly.

    YANG Description: tls hostname
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="tls-hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tls_hostname must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tls-hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='string', is_config=True)""",
        })

    self.__tls_hostname = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tls_hostname(self):
    self.__tls_hostname = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tls-hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='string', is_config=True)


  def _get_no_tls(self):
    """
    Getter method for no_tls, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv4_destinations/ipv4_destination/protocol/no_tls (uint32)

    YANG Description: no tls
    """
    return self.__no_tls
      
  def _set_no_tls(self, v, load=False):
    """
    Setter method for no_tls, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv4_destinations/ipv4_destination/protocol/no_tls (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_no_tls is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_no_tls() directly.

    YANG Description: no tls
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="no-tls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """no_tls must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="no-tls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__no_tls = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_no_tls(self):
    self.__no_tls = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="no-tls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='uint32', is_config=True)


  def _get_packetsize(self):
    """
    Getter method for packetsize, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv4_destinations/ipv4_destination/protocol/packetsize (uint32)

    YANG Description: udp packetsize
    """
    return self.__packetsize
      
  def _set_packetsize(self, v, load=False):
    """
    Setter method for packetsize, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv4_destinations/ipv4_destination/protocol/packetsize (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_packetsize is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_packetsize() directly.

    YANG Description: udp packetsize
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['484..65507']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1472), is_leaf=True, yang_name="packetsize", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """packetsize must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['484..65507']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1472), is_leaf=True, yang_name="packetsize", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__packetsize = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_packetsize(self):
    self.__packetsize = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['484..65507']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1472), is_leaf=True, yang_name="packetsize", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='uint32', is_config=True)

  protocol = __builtin__.property(_get_protocol, _set_protocol)
  tls_hostname = __builtin__.property(_get_tls_hostname, _set_tls_hostname)
  no_tls = __builtin__.property(_get_no_tls, _set_no_tls)
  packetsize = __builtin__.property(_get_packetsize, _set_packetsize)


  _pyangbind_elements = OrderedDict([('protocol', protocol), ('tls_hostname', tls_hostname), ('no_tls', no_tls), ('packetsize', packetsize), ])


class yc_ipv4_destination_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups_destination_group_ipv4_destinations_ipv4_destination(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-telemetry-model-driven-cfg - based on the path /telemetry-model-driven/destination-groups/destination-group/ipv4-destinations/ipv4-destination. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: destination IP address
  """
  __slots__ = ('_path_helper', '_extmethods', '__ipv4_address','__destination_port','__encoding','__protocol',)

  _yang_name = 'ipv4-destination'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__destination_port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="destination-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='xr:Cisco-ios-xr-port-number', is_config=True)
    self.__encoding = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'gpb': {'value': 2}, 'self-describing-gpb': {'value': 3}, 'json': {'value': 4}},), is_leaf=True, yang_name="encoding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='Encode-type', is_config=True)
    self.__protocol = YANGDynClass(base=yc_protocol_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups_destination_group_ipv4_destinations_ipv4_destination_protocol, is_container='container', yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['telemetry-model-driven', 'destination-groups', 'destination-group', 'ipv4-destinations', 'ipv4-destination']

  def _get_ipv4_address(self):
    """
    Getter method for ipv4_address, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv4_destinations/ipv4_destination/ipv4_address (inet:ipv4-address-no-zone)

    YANG Description: Destination IPv4 address
    """
    return self.__ipv4_address
      
  def _set_ipv4_address(self, v, load=False):
    """
    Setter method for ipv4_address, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv4_destinations/ipv4_destination/ipv4_address (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_address() directly.

    YANG Description: Destination IPv4 address
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_address must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__ipv4_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_address(self):
    self.__ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_destination_port(self):
    """
    Getter method for destination_port, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv4_destinations/ipv4_destination/destination_port (xr:Cisco-ios-xr-port-number)

    YANG Description: destination port
    """
    return self.__destination_port
      
  def _set_destination_port(self, v, load=False):
    """
    Setter method for destination_port, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv4_destinations/ipv4_destination/destination_port (xr:Cisco-ios-xr-port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_port() directly.

    YANG Description: destination port
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="destination-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='xr:Cisco-ios-xr-port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination_port must be of a type compatible with xr:Cisco-ios-xr-port-number""",
          'defined-type': "xr:Cisco-ios-xr-port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="destination-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='xr:Cisco-ios-xr-port-number', is_config=True)""",
        })

    self.__destination_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination_port(self):
    self.__destination_port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="destination-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='xr:Cisco-ios-xr-port-number', is_config=True)


  def _get_encoding(self):
    """
    Getter method for encoding, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv4_destinations/ipv4_destination/encoding (Encode-type)

    YANG Description: Encoding used to transmit telemetry data to the
collector
    """
    return self.__encoding
      
  def _set_encoding(self, v, load=False):
    """
    Setter method for encoding, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv4_destinations/ipv4_destination/encoding (Encode-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_encoding is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_encoding() directly.

    YANG Description: Encoding used to transmit telemetry data to the
collector
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'gpb': {'value': 2}, 'self-describing-gpb': {'value': 3}, 'json': {'value': 4}},), is_leaf=True, yang_name="encoding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='Encode-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """encoding must be of a type compatible with Encode-type""",
          'defined-type': "Cisco-IOS-XR-telemetry-model-driven-cfg:Encode-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'gpb': {'value': 2}, 'self-describing-gpb': {'value': 3}, 'json': {'value': 4}},), is_leaf=True, yang_name="encoding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='Encode-type', is_config=True)""",
        })

    self.__encoding = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_encoding(self):
    self.__encoding = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'gpb': {'value': 2}, 'self-describing-gpb': {'value': 3}, 'json': {'value': 4}},), is_leaf=True, yang_name="encoding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='Encode-type', is_config=True)


  def _get_protocol(self):
    """
    Getter method for protocol, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv4_destinations/ipv4_destination/protocol (container)

    YANG Description: Transport Protocol used to transmit telemetry
data to the collector
    """
    return self.__protocol
      
  def _set_protocol(self, v, load=False):
    """
    Setter method for protocol, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv4_destinations/ipv4_destination/protocol (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol() directly.

    YANG Description: Transport Protocol used to transmit telemetry
data to the collector
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_protocol_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups_destination_group_ipv4_destinations_ipv4_destination_protocol, is_container='container', yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_protocol_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups_destination_group_ipv4_destinations_ipv4_destination_protocol, is_container='container', yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)""",
        })

    self.__protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol(self):
    self.__protocol = YANGDynClass(base=yc_protocol_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups_destination_group_ipv4_destinations_ipv4_destination_protocol, is_container='container', yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)

  ipv4_address = __builtin__.property(_get_ipv4_address, _set_ipv4_address)
  destination_port = __builtin__.property(_get_destination_port, _set_destination_port)
  encoding = __builtin__.property(_get_encoding, _set_encoding)
  protocol = __builtin__.property(_get_protocol, _set_protocol)


  _pyangbind_elements = OrderedDict([('ipv4_address', ipv4_address), ('destination_port', destination_port), ('encoding', encoding), ('protocol', protocol), ])


class yc_ipv4_destinations_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups_destination_group_ipv4_destinations(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-telemetry-model-driven-cfg - based on the path /telemetry-model-driven/destination-groups/destination-group/ipv4-destinations. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Destination address configuration
  """
  __slots__ = ('_path_helper', '_extmethods', '__ipv4_destination',)

  _yang_name = 'ipv4-destinations'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ipv4_destination = YANGDynClass(base=YANGListType("ipv4_address destination_port",yc_ipv4_destination_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups_destination_group_ipv4_destinations_ipv4_destination, yang_name="ipv4-destination", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipv4-address destination-port', extensions=None), is_container='list', yang_name="ipv4-destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['telemetry-model-driven', 'destination-groups', 'destination-group', 'ipv4-destinations']

  def _get_ipv4_destination(self):
    """
    Getter method for ipv4_destination, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv4_destinations/ipv4_destination (list)

    YANG Description: destination IP address
    """
    return self.__ipv4_destination
      
  def _set_ipv4_destination(self, v, load=False):
    """
    Setter method for ipv4_destination, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv4_destinations/ipv4_destination (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_destination is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_destination() directly.

    YANG Description: destination IP address
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ipv4_address destination_port",yc_ipv4_destination_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups_destination_group_ipv4_destinations_ipv4_destination, yang_name="ipv4-destination", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipv4-address destination-port', extensions=None), is_container='list', yang_name="ipv4-destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_destination must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ipv4_address destination_port",yc_ipv4_destination_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups_destination_group_ipv4_destinations_ipv4_destination, yang_name="ipv4-destination", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipv4-address destination-port', extensions=None), is_container='list', yang_name="ipv4-destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='list', is_config=True)""",
        })

    self.__ipv4_destination = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_destination(self):
    self.__ipv4_destination = YANGDynClass(base=YANGListType("ipv4_address destination_port",yc_ipv4_destination_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups_destination_group_ipv4_destinations_ipv4_destination, yang_name="ipv4-destination", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipv4-address destination-port', extensions=None), is_container='list', yang_name="ipv4-destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='list', is_config=True)

  ipv4_destination = __builtin__.property(_get_ipv4_destination, _set_ipv4_destination)


  _pyangbind_elements = OrderedDict([('ipv4_destination', ipv4_destination), ])


class yc_destination_group_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups_destination_group(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-telemetry-model-driven-cfg - based on the path /telemetry-model-driven/destination-groups/destination-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Destination Group
  """
  __slots__ = ('_path_helper', '_extmethods', '__ipv6_destinations','__ipv4_destinations','__vrf','__destination_id',)

  _yang_name = 'destination-group'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ipv6_destinations = YANGDynClass(base=yc_ipv6_destinations_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups_destination_group_ipv6_destinations, is_container='container', yang_name="ipv6-destinations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)
    self.__ipv4_destinations = YANGDynClass(base=yc_ipv4_destinations_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups_destination_group_ipv4_destinations, is_container='container', yang_name="ipv4-destinations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)
    self.__vrf = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[\\w\\-\\.:,_@#%$\\+=\\|;]+'}), restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="vrf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='xr:Cisco-ios-xr-string', is_config=True)
    self.__destination_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[\\w\\-\\.:,_@#%$\\+=\\|;]+'}), is_leaf=True, yang_name="destination-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='xr:Cisco-ios-xr-string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['telemetry-model-driven', 'destination-groups', 'destination-group']

  def _get_ipv6_destinations(self):
    """
    Getter method for ipv6_destinations, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv6_destinations (container)

    YANG Description: Destination address configuration
    """
    return self.__ipv6_destinations
      
  def _set_ipv6_destinations(self, v, load=False):
    """
    Setter method for ipv6_destinations, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv6_destinations (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_destinations is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_destinations() directly.

    YANG Description: Destination address configuration
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv6_destinations_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups_destination_group_ipv6_destinations, is_container='container', yang_name="ipv6-destinations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_destinations must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv6_destinations_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups_destination_group_ipv6_destinations, is_container='container', yang_name="ipv6-destinations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)""",
        })

    self.__ipv6_destinations = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_destinations(self):
    self.__ipv6_destinations = YANGDynClass(base=yc_ipv6_destinations_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups_destination_group_ipv6_destinations, is_container='container', yang_name="ipv6-destinations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)


  def _get_ipv4_destinations(self):
    """
    Getter method for ipv4_destinations, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv4_destinations (container)

    YANG Description: Destination address configuration
    """
    return self.__ipv4_destinations
      
  def _set_ipv4_destinations(self, v, load=False):
    """
    Setter method for ipv4_destinations, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/ipv4_destinations (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_destinations is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_destinations() directly.

    YANG Description: Destination address configuration
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv4_destinations_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups_destination_group_ipv4_destinations, is_container='container', yang_name="ipv4-destinations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_destinations must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv4_destinations_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups_destination_group_ipv4_destinations, is_container='container', yang_name="ipv4-destinations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)""",
        })

    self.__ipv4_destinations = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_destinations(self):
    self.__ipv4_destinations = YANGDynClass(base=yc_ipv4_destinations_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups_destination_group_ipv4_destinations, is_container='container', yang_name="ipv4-destinations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)


  def _get_vrf(self):
    """
    Getter method for vrf, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/vrf (xr:Cisco-ios-xr-string)

    YANG Description: Vrf for the destination group
    """
    return self.__vrf
      
  def _set_vrf(self, v, load=False):
    """
    Setter method for vrf, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/vrf (xr:Cisco-ios-xr-string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrf() directly.

    YANG Description: Vrf for the destination group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[\\w\\-\\.:,_@#%$\\+=\\|;]+'}), restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="vrf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='xr:Cisco-ios-xr-string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrf must be of a type compatible with xr:Cisco-ios-xr-string""",
          'defined-type': "xr:Cisco-ios-xr-string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[\\w\\-\\.:,_@#%$\\+=\\|;]+'}), restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="vrf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='xr:Cisco-ios-xr-string', is_config=True)""",
        })

    self.__vrf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrf(self):
    self.__vrf = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[\\w\\-\\.:,_@#%$\\+=\\|;]+'}), restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="vrf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='xr:Cisco-ios-xr-string', is_config=True)


  def _get_destination_id(self):
    """
    Getter method for destination_id, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/destination_id (xr:Cisco-ios-xr-string)

    YANG Description: destination group id string
    """
    return self.__destination_id
      
  def _set_destination_id(self, v, load=False):
    """
    Setter method for destination_id, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group/destination_id (xr:Cisco-ios-xr-string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_id() directly.

    YANG Description: destination group id string
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[\\w\\-\\.:,_@#%$\\+=\\|;]+'}), is_leaf=True, yang_name="destination-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='xr:Cisco-ios-xr-string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination_id must be of a type compatible with xr:Cisco-ios-xr-string""",
          'defined-type': "xr:Cisco-ios-xr-string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[\\w\\-\\.:,_@#%$\\+=\\|;]+'}), is_leaf=True, yang_name="destination-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='xr:Cisco-ios-xr-string', is_config=True)""",
        })

    self.__destination_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination_id(self):
    self.__destination_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[\\w\\-\\.:,_@#%$\\+=\\|;]+'}), is_leaf=True, yang_name="destination-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='xr:Cisco-ios-xr-string', is_config=True)

  ipv6_destinations = __builtin__.property(_get_ipv6_destinations, _set_ipv6_destinations)
  ipv4_destinations = __builtin__.property(_get_ipv4_destinations, _set_ipv4_destinations)
  vrf = __builtin__.property(_get_vrf, _set_vrf)
  destination_id = __builtin__.property(_get_destination_id, _set_destination_id)


  _pyangbind_elements = OrderedDict([('ipv6_destinations', ipv6_destinations), ('ipv4_destinations', ipv4_destinations), ('vrf', vrf), ('destination_id', destination_id), ])


class yc_destination_groups_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-telemetry-model-driven-cfg - based on the path /telemetry-model-driven/destination-groups. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Destination Group configuration
  """
  __slots__ = ('_path_helper', '_extmethods', '__destination_group',)

  _yang_name = 'destination-groups'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__destination_group = YANGDynClass(base=YANGListType("destination_id",yc_destination_group_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups_destination_group, yang_name="destination-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='destination-id', extensions=None), is_container='list', yang_name="destination-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['telemetry-model-driven', 'destination-groups']

  def _get_destination_group(self):
    """
    Getter method for destination_group, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group (list)

    YANG Description: Destination Group
    """
    return self.__destination_group
      
  def _set_destination_group(self, v, load=False):
    """
    Setter method for destination_group, mapped from YANG variable /telemetry_model_driven/destination_groups/destination_group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_group() directly.

    YANG Description: Destination Group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("destination_id",yc_destination_group_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups_destination_group, yang_name="destination-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='destination-id', extensions=None), is_container='list', yang_name="destination-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination_group must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("destination_id",yc_destination_group_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups_destination_group, yang_name="destination-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='destination-id', extensions=None), is_container='list', yang_name="destination-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='list', is_config=True)""",
        })

    self.__destination_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination_group(self):
    self.__destination_group = YANGDynClass(base=YANGListType("destination_id",yc_destination_group_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups_destination_group, yang_name="destination-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='destination-id', extensions=None), is_container='list', yang_name="destination-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='list', is_config=True)

  destination_group = __builtin__.property(_get_destination_group, _set_destination_group)


  _pyangbind_elements = OrderedDict([('destination_group', destination_group), ])


class yc_telemetry_model_driven_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-telemetry-model-driven-cfg - based on the path /telemetry-model-driven. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Model Driven Telemetry configuration
  """
  __slots__ = ('_path_helper', '_extmethods', '__sensor_groups','__subscriptions','__include','__destination_groups','__strict_timer','__enable','__max_sensor_paths','__max_containers_per_path','__tcp_send_timeout',)

  _yang_name = 'telemetry-model-driven'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__sensor_groups = YANGDynClass(base=yc_sensor_groups_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_sensor_groups, is_container='container', yang_name="sensor-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)
    self.__subscriptions = YANGDynClass(base=yc_subscriptions_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_subscriptions, is_container='container', yang_name="subscriptions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)
    self.__include = YANGDynClass(base=yc_include_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_include, is_container='container', yang_name="include", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)
    self.__destination_groups = YANGDynClass(base=yc_destination_groups_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups, is_container='container', yang_name="destination-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)
    self.__strict_timer = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="strict-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='empty', is_config=True)
    self.__enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='empty', is_config=True)
    self.__max_sensor_paths = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4000']}), is_leaf=True, yang_name="max-sensor-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='uint32', is_config=True)
    self.__max_containers_per_path = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1024']}), is_leaf=True, yang_name="max-containers-per-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='uint32', is_config=True)
    self.__tcp_send_timeout = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..30']}), is_leaf=True, yang_name="tcp-send-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['telemetry-model-driven']

  def _get_sensor_groups(self):
    """
    Getter method for sensor_groups, mapped from YANG variable /telemetry_model_driven/sensor_groups (container)

    YANG Description: Sensor group configuration
    """
    return self.__sensor_groups
      
  def _set_sensor_groups(self, v, load=False):
    """
    Setter method for sensor_groups, mapped from YANG variable /telemetry_model_driven/sensor_groups (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sensor_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sensor_groups() directly.

    YANG Description: Sensor group configuration
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_sensor_groups_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_sensor_groups, is_container='container', yang_name="sensor-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sensor_groups must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_sensor_groups_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_sensor_groups, is_container='container', yang_name="sensor-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)""",
        })

    self.__sensor_groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sensor_groups(self):
    self.__sensor_groups = YANGDynClass(base=yc_sensor_groups_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_sensor_groups, is_container='container', yang_name="sensor-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)


  def _get_subscriptions(self):
    """
    Getter method for subscriptions, mapped from YANG variable /telemetry_model_driven/subscriptions (container)

    YANG Description: Streaming Telemetry Subscription
    """
    return self.__subscriptions
      
  def _set_subscriptions(self, v, load=False):
    """
    Setter method for subscriptions, mapped from YANG variable /telemetry_model_driven/subscriptions (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subscriptions is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subscriptions() directly.

    YANG Description: Streaming Telemetry Subscription
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_subscriptions_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_subscriptions, is_container='container', yang_name="subscriptions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subscriptions must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_subscriptions_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_subscriptions, is_container='container', yang_name="subscriptions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)""",
        })

    self.__subscriptions = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subscriptions(self):
    self.__subscriptions = YANGDynClass(base=yc_subscriptions_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_subscriptions, is_container='container', yang_name="subscriptions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)


  def _get_include(self):
    """
    Getter method for include, mapped from YANG variable /telemetry_model_driven/include (container)

    YANG Description: Include fields with empty values in output.
    """
    return self.__include
      
  def _set_include(self, v, load=False):
    """
    Setter method for include, mapped from YANG variable /telemetry_model_driven/include (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_include is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_include() directly.

    YANG Description: Include fields with empty values in output.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_include_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_include, is_container='container', yang_name="include", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """include must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_include_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_include, is_container='container', yang_name="include", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)""",
        })

    self.__include = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_include(self):
    self.__include = YANGDynClass(base=yc_include_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_include, is_container='container', yang_name="include", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)


  def _get_destination_groups(self):
    """
    Getter method for destination_groups, mapped from YANG variable /telemetry_model_driven/destination_groups (container)

    YANG Description: Destination Group configuration
    """
    return self.__destination_groups
      
  def _set_destination_groups(self, v, load=False):
    """
    Setter method for destination_groups, mapped from YANG variable /telemetry_model_driven/destination_groups (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_groups() directly.

    YANG Description: Destination Group configuration
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_destination_groups_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups, is_container='container', yang_name="destination-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination_groups must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_destination_groups_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups, is_container='container', yang_name="destination-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)""",
        })

    self.__destination_groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination_groups(self):
    self.__destination_groups = YANGDynClass(base=yc_destination_groups_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven_destination_groups, is_container='container', yang_name="destination-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)


  def _get_strict_timer(self):
    """
    Getter method for strict_timer, mapped from YANG variable /telemetry_model_driven/strict_timer (empty)

    YANG Description: enable strict-timer for all subscriptions,
default is relative timer
    """
    return self.__strict_timer
      
  def _set_strict_timer(self, v, load=False):
    """
    Setter method for strict_timer, mapped from YANG variable /telemetry_model_driven/strict_timer (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_strict_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_strict_timer() directly.

    YANG Description: enable strict-timer for all subscriptions,
default is relative timer
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="strict-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """strict_timer must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="strict-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='empty', is_config=True)""",
        })

    self.__strict_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_strict_timer(self):
    self.__strict_timer = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="strict-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='empty', is_config=True)


  def _get_enable(self):
    """
    Getter method for enable, mapped from YANG variable /telemetry_model_driven/enable (empty)

    YANG Description: Enable Model Driven Telemetry
    """
    return self.__enable
      
  def _set_enable(self, v, load=False):
    """
    Setter method for enable, mapped from YANG variable /telemetry_model_driven/enable (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable() directly.

    YANG Description: Enable Model Driven Telemetry
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='empty', is_config=True)""",
        })

    self.__enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable(self):
    self.__enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='empty', is_config=True)


  def _get_max_sensor_paths(self):
    """
    Getter method for max_sensor_paths, mapped from YANG variable /telemetry_model_driven/max_sensor_paths (uint32)

    YANG Description: Maximum allowed sensor paths, default: 1000
    """
    return self.__max_sensor_paths
      
  def _set_max_sensor_paths(self, v, load=False):
    """
    Setter method for max_sensor_paths, mapped from YANG variable /telemetry_model_driven/max_sensor_paths (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_sensor_paths is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_sensor_paths() directly.

    YANG Description: Maximum allowed sensor paths, default: 1000
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4000']}), is_leaf=True, yang_name="max-sensor-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_sensor_paths must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4000']}), is_leaf=True, yang_name="max-sensor-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__max_sensor_paths = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_sensor_paths(self):
    self.__max_sensor_paths = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4000']}), is_leaf=True, yang_name="max-sensor-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='uint32', is_config=True)


  def _get_max_containers_per_path(self):
    """
    Getter method for max_containers_per_path, mapped from YANG variable /telemetry_model_driven/max_containers_per_path (uint32)

    YANG Description: Maximum containers allowed per path, 0 disables
the check
    """
    return self.__max_containers_per_path
      
  def _set_max_containers_per_path(self, v, load=False):
    """
    Setter method for max_containers_per_path, mapped from YANG variable /telemetry_model_driven/max_containers_per_path (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_containers_per_path is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_containers_per_path() directly.

    YANG Description: Maximum containers allowed per path, 0 disables
the check
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1024']}), is_leaf=True, yang_name="max-containers-per-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_containers_per_path must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1024']}), is_leaf=True, yang_name="max-containers-per-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__max_containers_per_path = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_containers_per_path(self):
    self.__max_containers_per_path = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1024']}), is_leaf=True, yang_name="max-containers-per-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='uint32', is_config=True)


  def _get_tcp_send_timeout(self):
    """
    Getter method for tcp_send_timeout, mapped from YANG variable /telemetry_model_driven/tcp_send_timeout (uint32)

    YANG Description: TCP send timeout value, default:30 sec,0 will
disable the timeout
    """
    return self.__tcp_send_timeout
      
  def _set_tcp_send_timeout(self, v, load=False):
    """
    Setter method for tcp_send_timeout, mapped from YANG variable /telemetry_model_driven/tcp_send_timeout (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tcp_send_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tcp_send_timeout() directly.

    YANG Description: TCP send timeout value, default:30 sec,0 will
disable the timeout
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..30']}), is_leaf=True, yang_name="tcp-send-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tcp_send_timeout must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..30']}), is_leaf=True, yang_name="tcp-send-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__tcp_send_timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tcp_send_timeout(self):
    self.__tcp_send_timeout = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..30']}), is_leaf=True, yang_name="tcp-send-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='uint32', is_config=True)

  sensor_groups = __builtin__.property(_get_sensor_groups, _set_sensor_groups)
  subscriptions = __builtin__.property(_get_subscriptions, _set_subscriptions)
  include = __builtin__.property(_get_include, _set_include)
  destination_groups = __builtin__.property(_get_destination_groups, _set_destination_groups)
  strict_timer = __builtin__.property(_get_strict_timer, _set_strict_timer)
  enable = __builtin__.property(_get_enable, _set_enable)
  max_sensor_paths = __builtin__.property(_get_max_sensor_paths, _set_max_sensor_paths)
  max_containers_per_path = __builtin__.property(_get_max_containers_per_path, _set_max_containers_per_path)
  tcp_send_timeout = __builtin__.property(_get_tcp_send_timeout, _set_tcp_send_timeout)


  _pyangbind_elements = OrderedDict([('sensor_groups', sensor_groups), ('subscriptions', subscriptions), ('include', include), ('destination_groups', destination_groups), ('strict_timer', strict_timer), ('enable', enable), ('max_sensor_paths', max_sensor_paths), ('max_containers_per_path', max_containers_per_path), ('tcp_send_timeout', tcp_send_timeout), ])


class Cisco_IOS_XR_telemetry_model_driven_cfg(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-telemetry-model-driven-cfg - based on the path /Cisco-IOS-XR-telemetry-model-driven-cfg. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains a collection of YANG definitions
for Cisco IOS-XR telemetry-model-driven package configuration.

This module contains definitions
for the following management objects:
  telemetry-model-driven: Model Driven Telemetry configuration

Copyright (c) 2013-2018 by Cisco Systems, Inc.
All rights reserved.
  """
  __slots__ = ('_path_helper', '_extmethods', '__telemetry_model_driven',)

  _yang_name = 'Cisco-IOS-XR-telemetry-model-driven-cfg'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__telemetry_model_driven = YANGDynClass(base=yc_telemetry_model_driven_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven, is_container='container', yang_name="telemetry-model-driven", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_telemetry_model_driven(self):
    """
    Getter method for telemetry_model_driven, mapped from YANG variable /telemetry_model_driven (container)

    YANG Description: Model Driven Telemetry configuration
    """
    return self.__telemetry_model_driven
      
  def _set_telemetry_model_driven(self, v, load=False):
    """
    Setter method for telemetry_model_driven, mapped from YANG variable /telemetry_model_driven (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_telemetry_model_driven is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_telemetry_model_driven() directly.

    YANG Description: Model Driven Telemetry configuration
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_telemetry_model_driven_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven, is_container='container', yang_name="telemetry-model-driven", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """telemetry_model_driven must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_telemetry_model_driven_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven, is_container='container', yang_name="telemetry-model-driven", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)""",
        })

    self.__telemetry_model_driven = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_telemetry_model_driven(self):
    self.__telemetry_model_driven = YANGDynClass(base=yc_telemetry_model_driven_Cisco_IOS_XR_telemetry_model_driven_cfg__telemetry_model_driven, is_container='container', yang_name="telemetry-model-driven", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg', defining_module='Cisco-IOS-XR-telemetry-model-driven-cfg', yang_type='container', is_config=True)

  telemetry_model_driven = __builtin__.property(_get_telemetry_model_driven, _set_telemetry_model_driven)


  _pyangbind_elements = OrderedDict([('telemetry_model_driven', telemetry_model_driven), ])


class Cisco_IOS_XR_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-types - based on the path /Cisco-IOS-XR-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains a collection of IOS-XR derived YANG data
types.

Copyright (c) 2013-2018 by Cisco Systems, Inc.
All rights reserved.
  """
  _pyangbind_elements = {}

  

class ietf_inet_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-inet-types - based on the path /ietf-inet-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains a collection of generally useful derived
YANG data types for Internet addresses and related things.

Copyright (c) 2013 IETF Trust and the persons identified as
authors of the code.  All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject
to the license terms contained in, the Simplified BSD License
set forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(http://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC 6991; see
the RFC itself for full legal notices.
  """
  _pyangbind_elements = {}

  

