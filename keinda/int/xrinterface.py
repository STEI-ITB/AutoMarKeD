# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_global_interface_configuration_Cisco_IOS_XR_ifmgr_cfg__global_interface_configuration(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-ifmgr-cfg - based on the path /global-interface-configuration. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Global scoped configuration for interfaces
  """
  __slots__ = ('_path_helper', '_extmethods', '__link_status',)

  _yang_name = 'global-interface-configuration'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__link_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {'value': 0}, 'disable': {'value': 1}, 'software-interfaces': {'value': 2}},), default=six.text_type("default"), is_leaf=True, yang_name="link-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='Link-status-enum', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['global-interface-configuration']

  def _get_link_status(self):
    """
    Getter method for link_status, mapped from YANG variable /global_interface_configuration/link_status (Link-status-enum)

    YANG Description: Enable or disable link-status messages
    """
    return self.__link_status
      
  def _set_link_status(self, v, load=False):
    """
    Setter method for link_status, mapped from YANG variable /global_interface_configuration/link_status (Link-status-enum)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_status() directly.

    YANG Description: Enable or disable link-status messages
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {'value': 0}, 'disable': {'value': 1}, 'software-interfaces': {'value': 2}},), default=six.text_type("default"), is_leaf=True, yang_name="link-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='Link-status-enum', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_status must be of a type compatible with Link-status-enum""",
          'defined-type': "Cisco-IOS-XR-ifmgr-cfg:Link-status-enum",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {'value': 0}, 'disable': {'value': 1}, 'software-interfaces': {'value': 2}},), default=six.text_type("default"), is_leaf=True, yang_name="link-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='Link-status-enum', is_config=True)""",
        })

    self.__link_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_status(self):
    self.__link_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {'value': 0}, 'disable': {'value': 1}, 'software-interfaces': {'value': 2}},), default=six.text_type("default"), is_leaf=True, yang_name="link-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='Link-status-enum', is_config=True)

  link_status = __builtin__.property(_get_link_status, _set_link_status)


  _pyangbind_elements = OrderedDict([('link_status', link_status), ])


class yc_dampening_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_dampening(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-ifmgr-cfg - based on the path /interface-configurations/interface-configuration/dampening. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Whether this interface's state changes are
dampened or not
  """
  __slots__ = ('_path_helper', '_extmethods', '__args','__half_life','__reuse_threshold','__suppress_threshold','__suppress_time','__restart_penalty',)

  _yang_name = 'dampening'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__args = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default-values': {'value': 0}, 'specify-half-life': {'value': 1}, 'specify-all': {'value': 4}, 'specify-rp': {'value': 5}},), is_leaf=True, yang_name="args", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='enumeration', is_config=True)
    self.__half_life = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..45']}), is_leaf=True, yang_name="half-life", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)
    self.__reuse_threshold = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="reuse-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)
    self.__suppress_threshold = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="suppress-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)
    self.__suppress_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="suppress-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)
    self.__restart_penalty = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..20000']}), is_leaf=True, yang_name="restart-penalty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interface-configurations', 'interface-configuration', 'dampening']

  def _get_args(self):
    """
    Getter method for args, mapped from YANG variable /interface_configurations/interface_configuration/dampening/args (enumeration)

    YANG Description: Dampening Arguments
    """
    return self.__args
      
  def _set_args(self, v, load=False):
    """
    Setter method for args, mapped from YANG variable /interface_configurations/interface_configuration/dampening/args (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_args is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_args() directly.

    YANG Description: Dampening Arguments
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default-values': {'value': 0}, 'specify-half-life': {'value': 1}, 'specify-all': {'value': 4}, 'specify-rp': {'value': 5}},), is_leaf=True, yang_name="args", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """args must be of a type compatible with enumeration""",
          'defined-type': "Cisco-IOS-XR-ifmgr-cfg:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default-values': {'value': 0}, 'specify-half-life': {'value': 1}, 'specify-all': {'value': 4}, 'specify-rp': {'value': 5}},), is_leaf=True, yang_name="args", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='enumeration', is_config=True)""",
        })

    self.__args = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_args(self):
    self.__args = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default-values': {'value': 0}, 'specify-half-life': {'value': 1}, 'specify-all': {'value': 4}, 'specify-rp': {'value': 5}},), is_leaf=True, yang_name="args", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='enumeration', is_config=True)


  def _get_half_life(self):
    """
    Getter method for half_life, mapped from YANG variable /interface_configurations/interface_configuration/dampening/half_life (uint32)

    YANG Description: Decay half life (in minutes)
    """
    return self.__half_life
      
  def _set_half_life(self, v, load=False):
    """
    Setter method for half_life, mapped from YANG variable /interface_configurations/interface_configuration/dampening/half_life (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_half_life is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_half_life() directly.

    YANG Description: Decay half life (in minutes)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..45']}), is_leaf=True, yang_name="half-life", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """half_life must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..45']}), is_leaf=True, yang_name="half-life", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__half_life = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_half_life(self):
    self.__half_life = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..45']}), is_leaf=True, yang_name="half-life", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)


  def _get_reuse_threshold(self):
    """
    Getter method for reuse_threshold, mapped from YANG variable /interface_configurations/interface_configuration/dampening/reuse_threshold (uint32)

    YANG Description: Reuse threshold
    """
    return self.__reuse_threshold
      
  def _set_reuse_threshold(self, v, load=False):
    """
    Setter method for reuse_threshold, mapped from YANG variable /interface_configurations/interface_configuration/dampening/reuse_threshold (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reuse_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reuse_threshold() directly.

    YANG Description: Reuse threshold
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="reuse-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reuse_threshold must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="reuse-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__reuse_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reuse_threshold(self):
    self.__reuse_threshold = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="reuse-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)


  def _get_suppress_threshold(self):
    """
    Getter method for suppress_threshold, mapped from YANG variable /interface_configurations/interface_configuration/dampening/suppress_threshold (uint32)

    YANG Description: Suppress threshold
    """
    return self.__suppress_threshold
      
  def _set_suppress_threshold(self, v, load=False):
    """
    Setter method for suppress_threshold, mapped from YANG variable /interface_configurations/interface_configuration/dampening/suppress_threshold (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress_threshold() directly.

    YANG Description: Suppress threshold
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="suppress-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress_threshold must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="suppress-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__suppress_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress_threshold(self):
    self.__suppress_threshold = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="suppress-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)


  def _get_suppress_time(self):
    """
    Getter method for suppress_time, mapped from YANG variable /interface_configurations/interface_configuration/dampening/suppress_time (uint32)

    YANG Description: Max suppress time (in minutes)
    """
    return self.__suppress_time
      
  def _set_suppress_time(self, v, load=False):
    """
    Setter method for suppress_time, mapped from YANG variable /interface_configurations/interface_configuration/dampening/suppress_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress_time() directly.

    YANG Description: Max suppress time (in minutes)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="suppress-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="suppress-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__suppress_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress_time(self):
    self.__suppress_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="suppress-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)


  def _get_restart_penalty(self):
    """
    Getter method for restart_penalty, mapped from YANG variable /interface_configurations/interface_configuration/dampening/restart_penalty (uint32)

    YANG Description: Restart penalty
    """
    return self.__restart_penalty
      
  def _set_restart_penalty(self, v, load=False):
    """
    Setter method for restart_penalty, mapped from YANG variable /interface_configurations/interface_configuration/dampening/restart_penalty (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_penalty is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_penalty() directly.

    YANG Description: Restart penalty
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..20000']}), is_leaf=True, yang_name="restart-penalty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_penalty must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..20000']}), is_leaf=True, yang_name="restart-penalty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__restart_penalty = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_penalty(self):
    self.__restart_penalty = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..20000']}), is_leaf=True, yang_name="restart-penalty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)

  args = __builtin__.property(_get_args, _set_args)
  half_life = __builtin__.property(_get_half_life, _set_half_life)
  reuse_threshold = __builtin__.property(_get_reuse_threshold, _set_reuse_threshold)
  suppress_threshold = __builtin__.property(_get_suppress_threshold, _set_suppress_threshold)
  suppress_time = __builtin__.property(_get_suppress_time, _set_suppress_time)
  restart_penalty = __builtin__.property(_get_restart_penalty, _set_restart_penalty)


  _pyangbind_elements = OrderedDict([('args', args), ('half_life', half_life), ('reuse_threshold', reuse_threshold), ('suppress_threshold', suppress_threshold), ('suppress_time', suppress_time), ('restart_penalty', restart_penalty), ])


class yc_mtu_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_mtus_mtu(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-ifmgr-cfg - based on the path /interface-configurations/interface-configuration/mtus/mtu. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The MTU for the interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__owner','__mtu',)

  _yang_name = 'mtu'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__owner = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[\\w\\-\\.:,_@#%$\\+=\\|;]+'}), is_leaf=True, yang_name="owner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='xr:Cisco-ios-xr-string', is_config=True)
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['64..65535']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interface-configurations', 'interface-configuration', 'mtus', 'mtu']

  def _get_owner(self):
    """
    Getter method for owner, mapped from YANG variable /interface_configurations/interface_configuration/mtus/mtu/owner (xr:Cisco-ios-xr-string)

    YANG Description: The Owner of the interface - eg. for
'LoopbackX' main interface this is 'loopback'
    """
    return self.__owner
      
  def _set_owner(self, v, load=False):
    """
    Setter method for owner, mapped from YANG variable /interface_configurations/interface_configuration/mtus/mtu/owner (xr:Cisco-ios-xr-string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_owner is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_owner() directly.

    YANG Description: The Owner of the interface - eg. for
'LoopbackX' main interface this is 'loopback'
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[\\w\\-\\.:,_@#%$\\+=\\|;]+'}), is_leaf=True, yang_name="owner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='xr:Cisco-ios-xr-string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """owner must be of a type compatible with xr:Cisco-ios-xr-string""",
          'defined-type': "xr:Cisco-ios-xr-string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[\\w\\-\\.:,_@#%$\\+=\\|;]+'}), is_leaf=True, yang_name="owner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='xr:Cisco-ios-xr-string', is_config=True)""",
        })

    self.__owner = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_owner(self):
    self.__owner = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[\\w\\-\\.:,_@#%$\\+=\\|;]+'}), is_leaf=True, yang_name="owner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='xr:Cisco-ios-xr-string', is_config=True)


  def _get_mtu(self):
    """
    Getter method for mtu, mapped from YANG variable /interface_configurations/interface_configuration/mtus/mtu/mtu (uint32)

    YANG Description: The MTU value
    """
    return self.__mtu
      
  def _set_mtu(self, v, load=False):
    """
    Setter method for mtu, mapped from YANG variable /interface_configurations/interface_configuration/mtus/mtu/mtu (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: The MTU value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['64..65535']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['64..65535']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu(self):
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['64..65535']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)

  owner = __builtin__.property(_get_owner, _set_owner)
  mtu = __builtin__.property(_get_mtu, _set_mtu)


  _pyangbind_elements = OrderedDict([('owner', owner), ('mtu', mtu), ])


class yc_mtus_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_mtus(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-ifmgr-cfg - based on the path /interface-configurations/interface-configuration/mtus. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The MTU configuration for the interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__mtu',)

  _yang_name = 'mtus'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mtu = YANGDynClass(base=YANGListType("owner",yc_mtu_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_mtus_mtu, yang_name="mtu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='owner', extensions=None), is_container='list', yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interface-configurations', 'interface-configuration', 'mtus']

  def _get_mtu(self):
    """
    Getter method for mtu, mapped from YANG variable /interface_configurations/interface_configuration/mtus/mtu (list)

    YANG Description: The MTU for the interface
    """
    return self.__mtu
      
  def _set_mtu(self, v, load=False):
    """
    Setter method for mtu, mapped from YANG variable /interface_configurations/interface_configuration/mtus/mtu (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: The MTU for the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("owner",yc_mtu_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_mtus_mtu, yang_name="mtu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='owner', extensions=None), is_container='list', yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("owner",yc_mtu_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_mtus_mtu, yang_name="mtu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='owner', extensions=None), is_container='list', yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='list', is_config=True)""",
        })

    self.__mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu(self):
    self.__mtu = YANGDynClass(base=YANGListType("owner",yc_mtu_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_mtus_mtu, yang_name="mtu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='owner', extensions=None), is_container='list', yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='list', is_config=True)

  mtu = __builtin__.property(_get_mtu, _set_mtu)


  _pyangbind_elements = OrderedDict([('mtu', mtu), ])


class yc_encapsulation_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_encapsulation(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-ifmgr-cfg - based on the path /interface-configurations/interface-configuration/encapsulation. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The encapsulation on the interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__encapsulation','__capsulation_options',)

  _yang_name = 'encapsulation'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__encapsulation = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="encapsulation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='string', is_config=True)
    self.__capsulation_options = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="capsulation-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interface-configurations', 'interface-configuration', 'encapsulation']

  def _get_encapsulation(self):
    """
    Getter method for encapsulation, mapped from YANG variable /interface_configurations/interface_configuration/encapsulation/encapsulation (string)

    YANG Description: The encapsulation - e.g. hdlc, ppp
    """
    return self.__encapsulation
      
  def _set_encapsulation(self, v, load=False):
    """
    Setter method for encapsulation, mapped from YANG variable /interface_configurations/interface_configuration/encapsulation/encapsulation (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_encapsulation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_encapsulation() directly.

    YANG Description: The encapsulation - e.g. hdlc, ppp
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="encapsulation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """encapsulation must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="encapsulation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='string', is_config=True)""",
        })

    self.__encapsulation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_encapsulation(self):
    self.__encapsulation = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="encapsulation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='string', is_config=True)


  def _get_capsulation_options(self):
    """
    Getter method for capsulation_options, mapped from YANG variable /interface_configurations/interface_configuration/encapsulation/capsulation_options (uint32)

    YANG Description: The options for this capsulation, usually '0'
    """
    return self.__capsulation_options
      
  def _set_capsulation_options(self, v, load=False):
    """
    Setter method for capsulation_options, mapped from YANG variable /interface_configurations/interface_configuration/encapsulation/capsulation_options (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_capsulation_options is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_capsulation_options() directly.

    YANG Description: The options for this capsulation, usually '0'
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="capsulation-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """capsulation_options must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="capsulation-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__capsulation_options = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_capsulation_options(self):
    self.__capsulation_options = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="capsulation-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)

  encapsulation = __builtin__.property(_get_encapsulation, _set_encapsulation)
  capsulation_options = __builtin__.property(_get_capsulation_options, _set_capsulation_options)


  _pyangbind_elements = OrderedDict([('encapsulation', encapsulation), ('capsulation_options', capsulation_options), ])


class yc_input_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp_pa_input(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-ifmgr-cfg - based on the path /interface-configurations/interface-configuration/ipv4-network/bgp-pa/input. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Input
  """
  __slots__ = ('_path_helper', '_extmethods', '__source_accounting','__destination_accounting',)

  _yang_name = 'input'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__source_accounting = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="source-accounting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='boolean', is_config=True)
    self.__destination_accounting = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="destination-accounting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interface-configurations', 'interface-configuration', 'ipv4-network', 'bgp-pa', 'input']

  def _get_source_accounting(self):
    """
    Getter method for source_accounting, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/bgp_pa/input/source_accounting (boolean)

    YANG Description: BGP PA configuration on source
    """
    return self.__source_accounting
      
  def _set_source_accounting(self, v, load=False):
    """
    Setter method for source_accounting, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/bgp_pa/input/source_accounting (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_accounting is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_accounting() directly.

    YANG Description: BGP PA configuration on source
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="source-accounting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_accounting must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="source-accounting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='boolean', is_config=True)""",
        })

    self.__source_accounting = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_accounting(self):
    self.__source_accounting = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="source-accounting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='boolean', is_config=True)


  def _get_destination_accounting(self):
    """
    Getter method for destination_accounting, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/bgp_pa/input/destination_accounting (boolean)

    YANG Description: BGP PA configuration on destination
    """
    return self.__destination_accounting
      
  def _set_destination_accounting(self, v, load=False):
    """
    Setter method for destination_accounting, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/bgp_pa/input/destination_accounting (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_accounting is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_accounting() directly.

    YANG Description: BGP PA configuration on destination
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="destination-accounting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination_accounting must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="destination-accounting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='boolean', is_config=True)""",
        })

    self.__destination_accounting = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination_accounting(self):
    self.__destination_accounting = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="destination-accounting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='boolean', is_config=True)

  source_accounting = __builtin__.property(_get_source_accounting, _set_source_accounting)
  destination_accounting = __builtin__.property(_get_destination_accounting, _set_destination_accounting)


  _pyangbind_elements = OrderedDict([('source_accounting', source_accounting), ('destination_accounting', destination_accounting), ])


class yc_output_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp_pa_output(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-ifmgr-cfg - based on the path /interface-configurations/interface-configuration/ipv4-network/bgp-pa/output. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Output
  """
  __slots__ = ('_path_helper', '_extmethods', '__source_accounting','__destination_accounting',)

  _yang_name = 'output'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__source_accounting = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="source-accounting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='boolean', is_config=True)
    self.__destination_accounting = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="destination-accounting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interface-configurations', 'interface-configuration', 'ipv4-network', 'bgp-pa', 'output']

  def _get_source_accounting(self):
    """
    Getter method for source_accounting, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/bgp_pa/output/source_accounting (boolean)

    YANG Description: BGP PA configuration on source
    """
    return self.__source_accounting
      
  def _set_source_accounting(self, v, load=False):
    """
    Setter method for source_accounting, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/bgp_pa/output/source_accounting (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_accounting is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_accounting() directly.

    YANG Description: BGP PA configuration on source
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="source-accounting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_accounting must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="source-accounting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='boolean', is_config=True)""",
        })

    self.__source_accounting = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_accounting(self):
    self.__source_accounting = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="source-accounting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='boolean', is_config=True)


  def _get_destination_accounting(self):
    """
    Getter method for destination_accounting, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/bgp_pa/output/destination_accounting (boolean)

    YANG Description: BGP PA configuration on destination
    """
    return self.__destination_accounting
      
  def _set_destination_accounting(self, v, load=False):
    """
    Setter method for destination_accounting, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/bgp_pa/output/destination_accounting (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_accounting is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_accounting() directly.

    YANG Description: BGP PA configuration on destination
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="destination-accounting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination_accounting must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="destination-accounting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='boolean', is_config=True)""",
        })

    self.__destination_accounting = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination_accounting(self):
    self.__destination_accounting = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="destination-accounting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='boolean', is_config=True)

  source_accounting = __builtin__.property(_get_source_accounting, _set_source_accounting)
  destination_accounting = __builtin__.property(_get_destination_accounting, _set_destination_accounting)


  _pyangbind_elements = OrderedDict([('source_accounting', source_accounting), ('destination_accounting', destination_accounting), ])


class yc_bgp_pa_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp_pa(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-ifmgr-cfg - based on the path /interface-configurations/interface-configuration/ipv4-network/bgp-pa. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Interface ipv4 bgp configuration
  """
  __slots__ = ('_path_helper', '_extmethods', '__input','__output',)

  _yang_name = 'bgp-pa'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__input = YANGDynClass(base=yc_input_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp_pa_input, is_container='container', yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)
    self.__output = YANGDynClass(base=yc_output_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp_pa_output, is_container='container', yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interface-configurations', 'interface-configuration', 'ipv4-network', 'bgp-pa']

  def _get_input(self):
    """
    Getter method for input, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/bgp_pa/input (container)

    YANG Description: Input
    """
    return self.__input
      
  def _set_input(self, v, load=False):
    """
    Setter method for input, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/bgp_pa/input (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input() directly.

    YANG Description: Input
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_input_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp_pa_input, is_container='container', yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_input_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp_pa_input, is_container='container', yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)""",
        })

    self.__input = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input(self):
    self.__input = YANGDynClass(base=yc_input_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp_pa_input, is_container='container', yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)


  def _get_output(self):
    """
    Getter method for output, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/bgp_pa/output (container)

    YANG Description: Output
    """
    return self.__output
      
  def _set_output(self, v, load=False):
    """
    Setter method for output, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/bgp_pa/output (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output() directly.

    YANG Description: Output
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_output_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp_pa_output, is_container='container', yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_output_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp_pa_output, is_container='container', yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)""",
        })

    self.__output = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output(self):
    self.__output = YANGDynClass(base=yc_output_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp_pa_output, is_container='container', yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)

  input = __builtin__.property(_get_input, _set_input)
  output = __builtin__.property(_get_output, _set_output)


  _pyangbind_elements = OrderedDict([('input', input), ('output', output), ])


class yc_verify_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_verify(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-ifmgr-cfg - based on the path /interface-configurations/interface-configuration/ipv4-network/verify. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enable Verify handling for this interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__reachable','__self_ping','__default_ping',)

  _yang_name = 'verify'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__reachable = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'any': {'value': 0}, 'received': {'value': 1}},), is_leaf=True, yang_name="reachable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='Ipv4-reachable', is_config=True)
    self.__self_ping = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'disabled': {'value': 0}, 'enabled': {'value': 1}},), is_leaf=True, yang_name="self-ping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='Ipv4-self-ping', is_config=True)
    self.__default_ping = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'disabled': {'value': 0}, 'enabled': {'value': 1}},), is_leaf=True, yang_name="default-ping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='Ipv4-default-ping', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interface-configurations', 'interface-configuration', 'ipv4-network', 'verify']

  def _get_reachable(self):
    """
    Getter method for reachable, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/verify/reachable (Ipv4-reachable)

    YANG Description: Source is reachable via any interface or
interface on which packet was received
    """
    return self.__reachable
      
  def _set_reachable(self, v, load=False):
    """
    Setter method for reachable, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/verify/reachable (Ipv4-reachable)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reachable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reachable() directly.

    YANG Description: Source is reachable via any interface or
interface on which packet was received
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'any': {'value': 0}, 'received': {'value': 1}},), is_leaf=True, yang_name="reachable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='Ipv4-reachable', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reachable must be of a type compatible with Ipv4-reachable""",
          'defined-type': "Cisco-IOS-XR-ipv4-io-cfg:Ipv4-reachable",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'any': {'value': 0}, 'received': {'value': 1}},), is_leaf=True, yang_name="reachable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='Ipv4-reachable', is_config=True)""",
        })

    self.__reachable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reachable(self):
    self.__reachable = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'any': {'value': 0}, 'received': {'value': 1}},), is_leaf=True, yang_name="reachable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='Ipv4-reachable', is_config=True)


  def _get_self_ping(self):
    """
    Getter method for self_ping, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/verify/self_ping (Ipv4-self-ping)

    YANG Description: Allow router to ping itself (opens
vulnerability in verification)
    """
    return self.__self_ping
      
  def _set_self_ping(self, v, load=False):
    """
    Setter method for self_ping, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/verify/self_ping (Ipv4-self-ping)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_self_ping is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_self_ping() directly.

    YANG Description: Allow router to ping itself (opens
vulnerability in verification)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'disabled': {'value': 0}, 'enabled': {'value': 1}},), is_leaf=True, yang_name="self-ping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='Ipv4-self-ping', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """self_ping must be of a type compatible with Ipv4-self-ping""",
          'defined-type': "Cisco-IOS-XR-ipv4-io-cfg:Ipv4-self-ping",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'disabled': {'value': 0}, 'enabled': {'value': 1}},), is_leaf=True, yang_name="self-ping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='Ipv4-self-ping', is_config=True)""",
        })

    self.__self_ping = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_self_ping(self):
    self.__self_ping = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'disabled': {'value': 0}, 'enabled': {'value': 1}},), is_leaf=True, yang_name="self-ping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='Ipv4-self-ping', is_config=True)


  def _get_default_ping(self):
    """
    Getter method for default_ping, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/verify/default_ping (Ipv4-default-ping)

    YANG Description: Allow default route to match when checking
source address
    """
    return self.__default_ping
      
  def _set_default_ping(self, v, load=False):
    """
    Setter method for default_ping, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/verify/default_ping (Ipv4-default-ping)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_ping is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_ping() directly.

    YANG Description: Allow default route to match when checking
source address
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'disabled': {'value': 0}, 'enabled': {'value': 1}},), is_leaf=True, yang_name="default-ping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='Ipv4-default-ping', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_ping must be of a type compatible with Ipv4-default-ping""",
          'defined-type': "Cisco-IOS-XR-ipv4-io-cfg:Ipv4-default-ping",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'disabled': {'value': 0}, 'enabled': {'value': 1}},), is_leaf=True, yang_name="default-ping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='Ipv4-default-ping', is_config=True)""",
        })

    self.__default_ping = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_ping(self):
    self.__default_ping = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'disabled': {'value': 0}, 'enabled': {'value': 1}},), is_leaf=True, yang_name="default-ping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='Ipv4-default-ping', is_config=True)

  reachable = __builtin__.property(_get_reachable, _set_reachable)
  self_ping = __builtin__.property(_get_self_ping, _set_self_ping)
  default_ping = __builtin__.property(_get_default_ping, _set_default_ping)


  _pyangbind_elements = OrderedDict([('reachable', reachable), ('self_ping', self_ping), ('default_ping', default_ping), ])


class yc_input_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp_qppb_input(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-ifmgr-cfg - based on the path /interface-configurations/interface-configuration/ipv4-network/bgp/qppb/input. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Input
  """
  __slots__ = ('_path_helper', '_extmethods', '__source','__destination',)

  _yang_name = 'input'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__source = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ip-precedence': {'value': 1}, 'qos-group': {'value': 2}, 'both': {'value': 3}},), is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='Ipv4-interface-qppb', is_config=True)
    self.__destination = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ip-precedence': {'value': 1}, 'qos-group': {'value': 2}, 'both': {'value': 3}},), is_leaf=True, yang_name="destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='Ipv4-interface-qppb', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interface-configurations', 'interface-configuration', 'ipv4-network', 'bgp', 'qppb', 'input']

  def _get_source(self):
    """
    Getter method for source, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/bgp/qppb/input/source (Ipv4-interface-qppb)

    YANG Description: QPPB configuration on source
    """
    return self.__source
      
  def _set_source(self, v, load=False):
    """
    Setter method for source, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/bgp/qppb/input/source (Ipv4-interface-qppb)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source() directly.

    YANG Description: QPPB configuration on source
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ip-precedence': {'value': 1}, 'qos-group': {'value': 2}, 'both': {'value': 3}},), is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='Ipv4-interface-qppb', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source must be of a type compatible with Ipv4-interface-qppb""",
          'defined-type': "Cisco-IOS-XR-ipv4-io-cfg:Ipv4-interface-qppb",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ip-precedence': {'value': 1}, 'qos-group': {'value': 2}, 'both': {'value': 3}},), is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='Ipv4-interface-qppb', is_config=True)""",
        })

    self.__source = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source(self):
    self.__source = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ip-precedence': {'value': 1}, 'qos-group': {'value': 2}, 'both': {'value': 3}},), is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='Ipv4-interface-qppb', is_config=True)


  def _get_destination(self):
    """
    Getter method for destination, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/bgp/qppb/input/destination (Ipv4-interface-qppb)

    YANG Description: QPPB configuration on destination
    """
    return self.__destination
      
  def _set_destination(self, v, load=False):
    """
    Setter method for destination, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/bgp/qppb/input/destination (Ipv4-interface-qppb)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination() directly.

    YANG Description: QPPB configuration on destination
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ip-precedence': {'value': 1}, 'qos-group': {'value': 2}, 'both': {'value': 3}},), is_leaf=True, yang_name="destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='Ipv4-interface-qppb', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination must be of a type compatible with Ipv4-interface-qppb""",
          'defined-type': "Cisco-IOS-XR-ipv4-io-cfg:Ipv4-interface-qppb",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ip-precedence': {'value': 1}, 'qos-group': {'value': 2}, 'both': {'value': 3}},), is_leaf=True, yang_name="destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='Ipv4-interface-qppb', is_config=True)""",
        })

    self.__destination = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination(self):
    self.__destination = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ip-precedence': {'value': 1}, 'qos-group': {'value': 2}, 'both': {'value': 3}},), is_leaf=True, yang_name="destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='Ipv4-interface-qppb', is_config=True)

  source = __builtin__.property(_get_source, _set_source)
  destination = __builtin__.property(_get_destination, _set_destination)


  _pyangbind_elements = OrderedDict([('source', source), ('destination', destination), ])


class yc_qppb_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp_qppb(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-ifmgr-cfg - based on the path /interface-configurations/interface-configuration/ipv4-network/bgp/qppb. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Interface ipv4 bgp policy propagation
configuration
  """
  __slots__ = ('_path_helper', '_extmethods', '__input',)

  _yang_name = 'qppb'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__input = YANGDynClass(base=yc_input_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp_qppb_input, is_container='container', yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interface-configurations', 'interface-configuration', 'ipv4-network', 'bgp', 'qppb']

  def _get_input(self):
    """
    Getter method for input, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/bgp/qppb/input (container)

    YANG Description: Input
    """
    return self.__input
      
  def _set_input(self, v, load=False):
    """
    Setter method for input, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/bgp/qppb/input (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input() directly.

    YANG Description: Input
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_input_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp_qppb_input, is_container='container', yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_input_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp_qppb_input, is_container='container', yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)""",
        })

    self.__input = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input(self):
    self.__input = YANGDynClass(base=yc_input_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp_qppb_input, is_container='container', yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)

  input = __builtin__.property(_get_input, _set_input)


  _pyangbind_elements = OrderedDict([('input', input), ])


class yc_flow_tag_input_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp_flow_tag_flow_tag_input(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-ifmgr-cfg - based on the path /interface-configurations/interface-configuration/ipv4-network/bgp/flow-tag/flow-tag-input. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Input
  """
  __slots__ = ('_path_helper', '_extmethods', '__source','__destination',)

  _yang_name = 'flow-tag-input'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__source = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='boolean', is_config=True)
    self.__destination = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interface-configurations', 'interface-configuration', 'ipv4-network', 'bgp', 'flow-tag', 'flow-tag-input']

  def _get_source(self):
    """
    Getter method for source, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/bgp/flow_tag/flow_tag_input/source (boolean)

    YANG Description: FlowTag configuration on source
    """
    return self.__source
      
  def _set_source(self, v, load=False):
    """
    Setter method for source, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/bgp/flow_tag/flow_tag_input/source (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source() directly.

    YANG Description: FlowTag configuration on source
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='boolean', is_config=True)""",
        })

    self.__source = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source(self):
    self.__source = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='boolean', is_config=True)


  def _get_destination(self):
    """
    Getter method for destination, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/bgp/flow_tag/flow_tag_input/destination (boolean)

    YANG Description: FlowTag configuration on destination
    """
    return self.__destination
      
  def _set_destination(self, v, load=False):
    """
    Setter method for destination, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/bgp/flow_tag/flow_tag_input/destination (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination() directly.

    YANG Description: FlowTag configuration on destination
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='boolean', is_config=True)""",
        })

    self.__destination = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination(self):
    self.__destination = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='boolean', is_config=True)

  source = __builtin__.property(_get_source, _set_source)
  destination = __builtin__.property(_get_destination, _set_destination)


  _pyangbind_elements = OrderedDict([('source', source), ('destination', destination), ])


class yc_flow_tag_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp_flow_tag(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-ifmgr-cfg - based on the path /interface-configurations/interface-configuration/ipv4-network/bgp/flow-tag. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Interface ipv4 bgp policy propagation flow tag
configuration
  """
  __slots__ = ('_path_helper', '_extmethods', '__flow_tag_input',)

  _yang_name = 'flow-tag'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__flow_tag_input = YANGDynClass(base=yc_flow_tag_input_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp_flow_tag_flow_tag_input, is_container='container', yang_name="flow-tag-input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interface-configurations', 'interface-configuration', 'ipv4-network', 'bgp', 'flow-tag']

  def _get_flow_tag_input(self):
    """
    Getter method for flow_tag_input, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/bgp/flow_tag/flow_tag_input (container)

    YANG Description: Input
    """
    return self.__flow_tag_input
      
  def _set_flow_tag_input(self, v, load=False):
    """
    Setter method for flow_tag_input, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/bgp/flow_tag/flow_tag_input (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flow_tag_input is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flow_tag_input() directly.

    YANG Description: Input
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_flow_tag_input_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp_flow_tag_flow_tag_input, is_container='container', yang_name="flow-tag-input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flow_tag_input must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_flow_tag_input_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp_flow_tag_flow_tag_input, is_container='container', yang_name="flow-tag-input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)""",
        })

    self.__flow_tag_input = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flow_tag_input(self):
    self.__flow_tag_input = YANGDynClass(base=yc_flow_tag_input_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp_flow_tag_flow_tag_input, is_container='container', yang_name="flow-tag-input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)

  flow_tag_input = __builtin__.property(_get_flow_tag_input, _set_flow_tag_input)


  _pyangbind_elements = OrderedDict([('flow_tag_input', flow_tag_input), ])


class yc_bgp_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-ifmgr-cfg - based on the path /interface-configurations/interface-configuration/ipv4-network/bgp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Interface ipv4 bgp configuration
  """
  __slots__ = ('_path_helper', '_extmethods', '__qppb','__flow_tag',)

  _yang_name = 'bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__qppb = YANGDynClass(base=yc_qppb_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp_qppb, is_container='container', yang_name="qppb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)
    self.__flow_tag = YANGDynClass(base=yc_flow_tag_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp_flow_tag, is_container='container', yang_name="flow-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interface-configurations', 'interface-configuration', 'ipv4-network', 'bgp']

  def _get_qppb(self):
    """
    Getter method for qppb, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/bgp/qppb (container)

    YANG Description: Interface ipv4 bgp policy propagation
configuration
    """
    return self.__qppb
      
  def _set_qppb(self, v, load=False):
    """
    Setter method for qppb, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/bgp/qppb (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_qppb is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_qppb() directly.

    YANG Description: Interface ipv4 bgp policy propagation
configuration
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_qppb_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp_qppb, is_container='container', yang_name="qppb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """qppb must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_qppb_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp_qppb, is_container='container', yang_name="qppb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)""",
        })

    self.__qppb = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_qppb(self):
    self.__qppb = YANGDynClass(base=yc_qppb_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp_qppb, is_container='container', yang_name="qppb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)


  def _get_flow_tag(self):
    """
    Getter method for flow_tag, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/bgp/flow_tag (container)

    YANG Description: Interface ipv4 bgp policy propagation flow tag
configuration
    """
    return self.__flow_tag
      
  def _set_flow_tag(self, v, load=False):
    """
    Setter method for flow_tag, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/bgp/flow_tag (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flow_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flow_tag() directly.

    YANG Description: Interface ipv4 bgp policy propagation flow tag
configuration
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_flow_tag_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp_flow_tag, is_container='container', yang_name="flow-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flow_tag must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_flow_tag_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp_flow_tag, is_container='container', yang_name="flow-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)""",
        })

    self.__flow_tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flow_tag(self):
    self.__flow_tag = YANGDynClass(base=yc_flow_tag_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp_flow_tag, is_container='container', yang_name="flow-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)

  qppb = __builtin__.property(_get_qppb, _set_qppb)
  flow_tag = __builtin__.property(_get_flow_tag, _set_flow_tag)


  _pyangbind_elements = OrderedDict([('qppb', qppb), ('flow_tag', flow_tag), ])


class yc_secondary_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_addresses_secondaries_secondary(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-ifmgr-cfg - based on the path /interface-configurations/interface-configuration/ipv4-network/addresses/secondaries/secondary. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: IP address and Mask
  """
  __slots__ = ('_path_helper', '_extmethods', '__address','__netmask','__route_tag',)

  _yang_name = 'secondary'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__netmask = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="netmask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__route_tag = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="route-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interface-configurations', 'interface-configuration', 'ipv4-network', 'addresses', 'secondaries', 'secondary']

  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/addresses/secondaries/secondary/address (inet:ipv4-address-no-zone)

    YANG Description: Secondary IP address
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/addresses/secondaries/secondary/address (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: Secondary IP address
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_netmask(self):
    """
    Getter method for netmask, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/addresses/secondaries/secondary/netmask (inet:ipv4-address-no-zone)

    YANG Description: Netmask
    """
    return self.__netmask
      
  def _set_netmask(self, v, load=False):
    """
    Setter method for netmask, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/addresses/secondaries/secondary/netmask (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_netmask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_netmask() directly.

    YANG Description: Netmask
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="netmask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """netmask must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="netmask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__netmask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_netmask(self):
    self.__netmask = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="netmask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_route_tag(self):
    """
    Getter method for route_tag, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/addresses/secondaries/secondary/route_tag (uint32)

    YANG Description: RouteTag
    """
    return self.__route_tag
      
  def _set_route_tag(self, v, load=False):
    """
    Setter method for route_tag, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/addresses/secondaries/secondary/route_tag (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_tag() directly.

    YANG Description: RouteTag
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="route-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_tag must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="route-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__route_tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_tag(self):
    self.__route_tag = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="route-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='uint32', is_config=True)

  address = __builtin__.property(_get_address, _set_address)
  netmask = __builtin__.property(_get_netmask, _set_netmask)
  route_tag = __builtin__.property(_get_route_tag, _set_route_tag)


  _pyangbind_elements = OrderedDict([('address', address), ('netmask', netmask), ('route_tag', route_tag), ])


class yc_secondaries_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_addresses_secondaries(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-ifmgr-cfg - based on the path /interface-configurations/interface-configuration/ipv4-network/addresses/secondaries. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specify a secondary address
  """
  __slots__ = ('_path_helper', '_extmethods', '__secondary',)

  _yang_name = 'secondaries'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__secondary = YANGDynClass(base=YANGListType("address",yc_secondary_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_addresses_secondaries_secondary, yang_name="secondary", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="secondary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interface-configurations', 'interface-configuration', 'ipv4-network', 'addresses', 'secondaries']

  def _get_secondary(self):
    """
    Getter method for secondary, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/addresses/secondaries/secondary (list)

    YANG Description: IP address and Mask
    """
    return self.__secondary
      
  def _set_secondary(self, v, load=False):
    """
    Setter method for secondary, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/addresses/secondaries/secondary (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_secondary is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_secondary() directly.

    YANG Description: IP address and Mask
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("address",yc_secondary_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_addresses_secondaries_secondary, yang_name="secondary", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="secondary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """secondary must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("address",yc_secondary_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_addresses_secondaries_secondary, yang_name="secondary", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="secondary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='list', is_config=True)""",
        })

    self.__secondary = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_secondary(self):
    self.__secondary = YANGDynClass(base=YANGListType("address",yc_secondary_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_addresses_secondaries_secondary, yang_name="secondary", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="secondary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='list', is_config=True)

  secondary = __builtin__.property(_get_secondary, _set_secondary)


  _pyangbind_elements = OrderedDict([('secondary', secondary), ])


class yc_primary_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_addresses_primary(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-ifmgr-cfg - based on the path /interface-configurations/interface-configuration/ipv4-network/addresses/primary. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: IP address and Mask
  """
  __slots__ = ('_path_helper', '_extmethods', '__address','__netmask','__route_tag',)

  _yang_name = 'primary'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__netmask = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="netmask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__route_tag = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="route-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interface-configurations', 'interface-configuration', 'ipv4-network', 'addresses', 'primary']

  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/addresses/primary/address (inet:ipv4-address-no-zone)

    YANG Description: IP address
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/addresses/primary/address (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: IP address
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_netmask(self):
    """
    Getter method for netmask, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/addresses/primary/netmask (inet:ipv4-address-no-zone)

    YANG Description: Netmask
    """
    return self.__netmask
      
  def _set_netmask(self, v, load=False):
    """
    Setter method for netmask, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/addresses/primary/netmask (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_netmask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_netmask() directly.

    YANG Description: Netmask
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="netmask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """netmask must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="netmask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__netmask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_netmask(self):
    self.__netmask = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="netmask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_route_tag(self):
    """
    Getter method for route_tag, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/addresses/primary/route_tag (uint32)

    YANG Description: RouteTag
    """
    return self.__route_tag
      
  def _set_route_tag(self, v, load=False):
    """
    Setter method for route_tag, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/addresses/primary/route_tag (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_tag() directly.

    YANG Description: RouteTag
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="route-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_tag must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="route-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__route_tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_tag(self):
    self.__route_tag = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="route-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='uint32', is_config=True)

  address = __builtin__.property(_get_address, _set_address)
  netmask = __builtin__.property(_get_netmask, _set_netmask)
  route_tag = __builtin__.property(_get_route_tag, _set_route_tag)


  _pyangbind_elements = OrderedDict([('address', address), ('netmask', netmask), ('route_tag', route_tag), ])


class yc_addresses_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_addresses(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-ifmgr-cfg - based on the path /interface-configurations/interface-configuration/ipv4-network/addresses. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Set the IP address of an interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__secondaries','__primary','__unnumbered','__dhcp',)

  _yang_name = 'addresses'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__secondaries = YANGDynClass(base=yc_secondaries_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_addresses_secondaries, is_container='container', yang_name="secondaries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)
    self.__primary = YANGDynClass(base=yc_primary_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_addresses_primary, is_container='container', yang_name="primary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)
    self.__unnumbered = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z0-9._/-]+'}), is_leaf=True, yang_name="unnumbered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='xr:Interface-name', is_config=True)
    self.__dhcp = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dhcp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='empty', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interface-configurations', 'interface-configuration', 'ipv4-network', 'addresses']

  def _get_secondaries(self):
    """
    Getter method for secondaries, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/addresses/secondaries (container)

    YANG Description: Specify a secondary address
    """
    return self.__secondaries
      
  def _set_secondaries(self, v, load=False):
    """
    Setter method for secondaries, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/addresses/secondaries (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_secondaries is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_secondaries() directly.

    YANG Description: Specify a secondary address
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_secondaries_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_addresses_secondaries, is_container='container', yang_name="secondaries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """secondaries must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_secondaries_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_addresses_secondaries, is_container='container', yang_name="secondaries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)""",
        })

    self.__secondaries = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_secondaries(self):
    self.__secondaries = YANGDynClass(base=yc_secondaries_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_addresses_secondaries, is_container='container', yang_name="secondaries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)


  def _get_primary(self):
    """
    Getter method for primary, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/addresses/primary (container)

    YANG Description: IP address and Mask
    """
    return self.__primary
      
  def _set_primary(self, v, load=False):
    """
    Setter method for primary, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/addresses/primary (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_primary is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_primary() directly.

    YANG Description: IP address and Mask
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_primary_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_addresses_primary, is_container='container', yang_name="primary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """primary must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_primary_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_addresses_primary, is_container='container', yang_name="primary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)""",
        })

    self.__primary = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_primary(self):
    self.__primary = YANGDynClass(base=yc_primary_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_addresses_primary, is_container='container', yang_name="primary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)


  def _get_unnumbered(self):
    """
    Getter method for unnumbered, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/addresses/unnumbered (xr:Interface-name)

    YANG Description: Enable IP processing without an explicit
address
    """
    return self.__unnumbered
      
  def _set_unnumbered(self, v, load=False):
    """
    Setter method for unnumbered, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/addresses/unnumbered (xr:Interface-name)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unnumbered is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unnumbered() directly.

    YANG Description: Enable IP processing without an explicit
address
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z0-9._/-]+'}), is_leaf=True, yang_name="unnumbered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='xr:Interface-name', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unnumbered must be of a type compatible with xr:Interface-name""",
          'defined-type': "xr:Interface-name",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z0-9._/-]+'}), is_leaf=True, yang_name="unnumbered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='xr:Interface-name', is_config=True)""",
        })

    self.__unnumbered = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unnumbered(self):
    self.__unnumbered = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z0-9._/-]+'}), is_leaf=True, yang_name="unnumbered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='xr:Interface-name', is_config=True)


  def _get_dhcp(self):
    """
    Getter method for dhcp, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/addresses/dhcp (empty)

    YANG Description: IPv4 address and Mask negotiated via DHCP
    """
    return self.__dhcp
      
  def _set_dhcp(self, v, load=False):
    """
    Setter method for dhcp, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/addresses/dhcp (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp() directly.

    YANG Description: IPv4 address and Mask negotiated via DHCP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dhcp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dhcp must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dhcp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='empty', is_config=True)""",
        })

    self.__dhcp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dhcp(self):
    self.__dhcp = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dhcp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='empty', is_config=True)

  secondaries = __builtin__.property(_get_secondaries, _set_secondaries)
  primary = __builtin__.property(_get_primary, _set_primary)
  unnumbered = __builtin__.property(_get_unnumbered, _set_unnumbered)
  dhcp = __builtin__.property(_get_dhcp, _set_dhcp)


  _pyangbind_elements = OrderedDict([('secondaries', secondaries), ('primary', primary), ('unnumbered', unnumbered), ('dhcp', dhcp), ])


class yc_helper_address_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_helper_addresses_helper_address(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-ifmgr-cfg - based on the path /interface-configurations/interface-configuration/ipv4-network/helper-addresses/helper-address. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An IP destination addresses for UDP broadcasts
  """
  __slots__ = ('_path_helper', '_extmethods', '__address','__vrf_name',)

  _yang_name = 'helper-address'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__vrf_name = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[\\w\\-\\.:,_@#%$\\+=\\|;]+'}), restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="vrf-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='xr:Cisco-ios-xr-string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interface-configurations', 'interface-configuration', 'ipv4-network', 'helper-addresses', 'helper-address']

  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/helper_addresses/helper_address/address (inet:ipv4-address-no-zone)

    YANG Description: IP destination address
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/helper_addresses/helper_address/address (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: IP destination address
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_vrf_name(self):
    """
    Getter method for vrf_name, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/helper_addresses/helper_address/vrf_name (xr:Cisco-ios-xr-string)

    YANG Description: VRF name
    """
    return self.__vrf_name
      
  def _set_vrf_name(self, v, load=False):
    """
    Setter method for vrf_name, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/helper_addresses/helper_address/vrf_name (xr:Cisco-ios-xr-string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrf_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrf_name() directly.

    YANG Description: VRF name
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[\\w\\-\\.:,_@#%$\\+=\\|;]+'}), restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="vrf-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='xr:Cisco-ios-xr-string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrf_name must be of a type compatible with xr:Cisco-ios-xr-string""",
          'defined-type': "xr:Cisco-ios-xr-string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[\\w\\-\\.:,_@#%$\\+=\\|;]+'}), restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="vrf-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='xr:Cisco-ios-xr-string', is_config=True)""",
        })

    self.__vrf_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrf_name(self):
    self.__vrf_name = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[\\w\\-\\.:,_@#%$\\+=\\|;]+'}), restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="vrf-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='xr:Cisco-ios-xr-string', is_config=True)

  address = __builtin__.property(_get_address, _set_address)
  vrf_name = __builtin__.property(_get_vrf_name, _set_vrf_name)


  _pyangbind_elements = OrderedDict([('address', address), ('vrf_name', vrf_name), ])


class yc_helper_addresses_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_helper_addresses(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-ifmgr-cfg - based on the path /interface-configurations/interface-configuration/ipv4-network/helper-addresses. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The set of IP destination addresses for UDP
broadcasts
  """
  __slots__ = ('_path_helper', '_extmethods', '__helper_address',)

  _yang_name = 'helper-addresses'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__helper_address = YANGDynClass(base=YANGListType("address vrf_name",yc_helper_address_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_helper_addresses_helper_address, yang_name="helper-address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address vrf-name', extensions=None), is_container='list', yang_name="helper-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interface-configurations', 'interface-configuration', 'ipv4-network', 'helper-addresses']

  def _get_helper_address(self):
    """
    Getter method for helper_address, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/helper_addresses/helper_address (list)

    YANG Description: An IP destination addresses for UDP broadcasts
    """
    return self.__helper_address
      
  def _set_helper_address(self, v, load=False):
    """
    Setter method for helper_address, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/helper_addresses/helper_address (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_helper_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_helper_address() directly.

    YANG Description: An IP destination addresses for UDP broadcasts
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("address vrf_name",yc_helper_address_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_helper_addresses_helper_address, yang_name="helper-address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address vrf-name', extensions=None), is_container='list', yang_name="helper-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """helper_address must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("address vrf_name",yc_helper_address_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_helper_addresses_helper_address, yang_name="helper-address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address vrf-name', extensions=None), is_container='list', yang_name="helper-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='list', is_config=True)""",
        })

    self.__helper_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_helper_address(self):
    self.__helper_address = YANGDynClass(base=YANGListType("address vrf_name",yc_helper_address_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_helper_addresses_helper_address, yang_name="helper-address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address vrf-name', extensions=None), is_container='list', yang_name="helper-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='list', is_config=True)

  helper_address = __builtin__.property(_get_helper_address, _set_helper_address)


  _pyangbind_elements = OrderedDict([('helper_address', helper_address), ])


class yc_ipv4_network_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-ifmgr-cfg - based on the path /interface-configurations/interface-configuration/ipv4-network. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Interface IPv4 Network configuration data
  """
  __slots__ = ('_path_helper', '_extmethods', '__bgp_pa','__verify','__bgp','__addresses','__helper_addresses','__forwarding_enable','__icmp_mask_reply','__tcp_mss_adjust_enable','__ttl_propagate_disable','__point_to_point','__mtu',)

  _yang_name = 'ipv4-network'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__bgp_pa = YANGDynClass(base=yc_bgp_pa_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp_pa, is_container='container', yang_name="bgp-pa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)
    self.__verify = YANGDynClass(base=yc_verify_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_verify, is_container='container', yang_name="verify", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)
    self.__bgp = YANGDynClass(base=yc_bgp_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)
    self.__addresses = YANGDynClass(base=yc_addresses_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)
    self.__helper_addresses = YANGDynClass(base=yc_helper_addresses_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_helper_addresses, is_container='container', yang_name="helper-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)
    self.__forwarding_enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="forwarding-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='empty', is_config=True)
    self.__icmp_mask_reply = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="icmp-mask-reply", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='empty', is_config=True)
    self.__tcp_mss_adjust_enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="tcp-mss-adjust-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='empty', is_config=True)
    self.__ttl_propagate_disable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ttl-propagate-disable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='empty', is_config=True)
    self.__point_to_point = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="point-to-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='empty', is_config=True)
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['68..65535']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interface-configurations', 'interface-configuration', 'ipv4-network']

  def _get_bgp_pa(self):
    """
    Getter method for bgp_pa, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/bgp_pa (container)

    YANG Description: Interface ipv4 bgp configuration
    """
    return self.__bgp_pa
      
  def _set_bgp_pa(self, v, load=False):
    """
    Setter method for bgp_pa, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/bgp_pa (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgp_pa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgp_pa() directly.

    YANG Description: Interface ipv4 bgp configuration
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_bgp_pa_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp_pa, is_container='container', yang_name="bgp-pa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgp_pa must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_bgp_pa_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp_pa, is_container='container', yang_name="bgp-pa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)""",
        })

    self.__bgp_pa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgp_pa(self):
    self.__bgp_pa = YANGDynClass(base=yc_bgp_pa_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp_pa, is_container='container', yang_name="bgp-pa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)


  def _get_verify(self):
    """
    Getter method for verify, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/verify (container)

    YANG Description: Enable Verify handling for this interface
    """
    return self.__verify
      
  def _set_verify(self, v, load=False):
    """
    Setter method for verify, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/verify (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_verify is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_verify() directly.

    YANG Description: Enable Verify handling for this interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_verify_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_verify, is_container='container', yang_name="verify", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """verify must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_verify_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_verify, is_container='container', yang_name="verify", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)""",
        })

    self.__verify = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_verify(self):
    self.__verify = YANGDynClass(base=yc_verify_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_verify, is_container='container', yang_name="verify", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)


  def _get_bgp(self):
    """
    Getter method for bgp, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/bgp (container)

    YANG Description: Interface ipv4 bgp configuration
    """
    return self.__bgp
      
  def _set_bgp(self, v, load=False):
    """
    Setter method for bgp, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/bgp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgp() directly.

    YANG Description: Interface ipv4 bgp configuration
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_bgp_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_bgp_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)""",
        })

    self.__bgp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgp(self):
    self.__bgp = YANGDynClass(base=yc_bgp_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)


  def _get_addresses(self):
    """
    Getter method for addresses, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/addresses (container)

    YANG Description: Set the IP address of an interface
    """
    return self.__addresses
      
  def _set_addresses(self, v, load=False):
    """
    Setter method for addresses, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/addresses (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_addresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_addresses() directly.

    YANG Description: Set the IP address of an interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_addresses_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """addresses must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_addresses_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)""",
        })

    self.__addresses = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_addresses(self):
    self.__addresses = YANGDynClass(base=yc_addresses_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)


  def _get_helper_addresses(self):
    """
    Getter method for helper_addresses, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/helper_addresses (container)

    YANG Description: The set of IP destination addresses for UDP
broadcasts
    """
    return self.__helper_addresses
      
  def _set_helper_addresses(self, v, load=False):
    """
    Setter method for helper_addresses, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/helper_addresses (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_helper_addresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_helper_addresses() directly.

    YANG Description: The set of IP destination addresses for UDP
broadcasts
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_helper_addresses_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_helper_addresses, is_container='container', yang_name="helper-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """helper_addresses must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_helper_addresses_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_helper_addresses, is_container='container', yang_name="helper-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)""",
        })

    self.__helper_addresses = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_helper_addresses(self):
    self.__helper_addresses = YANGDynClass(base=yc_helper_addresses_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_helper_addresses, is_container='container', yang_name="helper-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)


  def _get_forwarding_enable(self):
    """
    Getter method for forwarding_enable, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/forwarding_enable (empty)

    YANG Description: IPv4 forwarding to get enabled on an interface
    """
    return self.__forwarding_enable
      
  def _set_forwarding_enable(self, v, load=False):
    """
    Setter method for forwarding_enable, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/forwarding_enable (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_forwarding_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_forwarding_enable() directly.

    YANG Description: IPv4 forwarding to get enabled on an interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="forwarding-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """forwarding_enable must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="forwarding-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='empty', is_config=True)""",
        })

    self.__forwarding_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_forwarding_enable(self):
    self.__forwarding_enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="forwarding-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='empty', is_config=True)


  def _get_icmp_mask_reply(self):
    """
    Getter method for icmp_mask_reply, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/icmp_mask_reply (empty)

    YANG Description: The flag for enabling sending of ICMP mask
reply messages
    """
    return self.__icmp_mask_reply
      
  def _set_icmp_mask_reply(self, v, load=False):
    """
    Setter method for icmp_mask_reply, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/icmp_mask_reply (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_icmp_mask_reply is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_icmp_mask_reply() directly.

    YANG Description: The flag for enabling sending of ICMP mask
reply messages
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="icmp-mask-reply", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """icmp_mask_reply must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="icmp-mask-reply", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='empty', is_config=True)""",
        })

    self.__icmp_mask_reply = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_icmp_mask_reply(self):
    self.__icmp_mask_reply = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="icmp-mask-reply", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='empty', is_config=True)


  def _get_tcp_mss_adjust_enable(self):
    """
    Getter method for tcp_mss_adjust_enable, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/tcp_mss_adjust_enable (empty)

    YANG Description: Enable TCP MSS Adjust on an interface
    """
    return self.__tcp_mss_adjust_enable
      
  def _set_tcp_mss_adjust_enable(self, v, load=False):
    """
    Setter method for tcp_mss_adjust_enable, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/tcp_mss_adjust_enable (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tcp_mss_adjust_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tcp_mss_adjust_enable() directly.

    YANG Description: Enable TCP MSS Adjust on an interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="tcp-mss-adjust-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tcp_mss_adjust_enable must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="tcp-mss-adjust-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='empty', is_config=True)""",
        })

    self.__tcp_mss_adjust_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tcp_mss_adjust_enable(self):
    self.__tcp_mss_adjust_enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="tcp-mss-adjust-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='empty', is_config=True)


  def _get_ttl_propagate_disable(self):
    """
    Getter method for ttl_propagate_disable, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/ttl_propagate_disable (empty)

    YANG Description: Disable TTL propagate on an interface
    """
    return self.__ttl_propagate_disable
      
  def _set_ttl_propagate_disable(self, v, load=False):
    """
    Setter method for ttl_propagate_disable, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/ttl_propagate_disable (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ttl_propagate_disable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ttl_propagate_disable() directly.

    YANG Description: Disable TTL propagate on an interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="ttl-propagate-disable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ttl_propagate_disable must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ttl-propagate-disable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='empty', is_config=True)""",
        })

    self.__ttl_propagate_disable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ttl_propagate_disable(self):
    self.__ttl_propagate_disable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ttl-propagate-disable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='empty', is_config=True)


  def _get_point_to_point(self):
    """
    Getter method for point_to_point, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/point_to_point (empty)

    YANG Description: Enable point-to-point handling for this
interface.
    """
    return self.__point_to_point
      
  def _set_point_to_point(self, v, load=False):
    """
    Setter method for point_to_point, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/point_to_point (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_point_to_point is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_point_to_point() directly.

    YANG Description: Enable point-to-point handling for this
interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="point-to-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """point_to_point must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="point-to-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='empty', is_config=True)""",
        })

    self.__point_to_point = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_point_to_point(self):
    self.__point_to_point = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="point-to-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='empty', is_config=True)


  def _get_mtu(self):
    """
    Getter method for mtu, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/mtu (uint32)

    YANG Description: The IP Maximum Transmission Unit
    """
    return self.__mtu
      
  def _set_mtu(self, v, load=False):
    """
    Setter method for mtu, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network/mtu (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: The IP Maximum Transmission Unit
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['68..65535']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['68..65535']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu(self):
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['68..65535']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='uint32', is_config=True)

  bgp_pa = __builtin__.property(_get_bgp_pa, _set_bgp_pa)
  verify = __builtin__.property(_get_verify, _set_verify)
  bgp = __builtin__.property(_get_bgp, _set_bgp)
  addresses = __builtin__.property(_get_addresses, _set_addresses)
  helper_addresses = __builtin__.property(_get_helper_addresses, _set_helper_addresses)
  forwarding_enable = __builtin__.property(_get_forwarding_enable, _set_forwarding_enable)
  icmp_mask_reply = __builtin__.property(_get_icmp_mask_reply, _set_icmp_mask_reply)
  tcp_mss_adjust_enable = __builtin__.property(_get_tcp_mss_adjust_enable, _set_tcp_mss_adjust_enable)
  ttl_propagate_disable = __builtin__.property(_get_ttl_propagate_disable, _set_ttl_propagate_disable)
  point_to_point = __builtin__.property(_get_point_to_point, _set_point_to_point)
  mtu = __builtin__.property(_get_mtu, _set_mtu)


  _pyangbind_elements = OrderedDict([('bgp_pa', bgp_pa), ('verify', verify), ('bgp', bgp), ('addresses', addresses), ('helper_addresses', helper_addresses), ('forwarding_enable', forwarding_enable), ('icmp_mask_reply', icmp_mask_reply), ('tcp_mss_adjust_enable', tcp_mss_adjust_enable), ('ttl_propagate_disable', ttl_propagate_disable), ('point_to_point', point_to_point), ('mtu', mtu), ])


class yc_ipv4_network_forwarding_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_forwarding(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-ifmgr-cfg - based on the path /interface-configurations/interface-configuration/ipv4-network-forwarding. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Interface IPv4 Network configuration data also
used for forwarding
  """
  __slots__ = ('_path_helper', '_extmethods', '__directed_broadcast','__unreachables','__redirects',)

  _yang_name = 'ipv4-network-forwarding'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__directed_broadcast = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="directed-broadcast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='empty', is_config=True)
    self.__unreachables = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="unreachables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='empty', is_config=True)
    self.__redirects = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="redirects", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='empty', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interface-configurations', 'interface-configuration', 'ipv4-network-forwarding']

  def _get_directed_broadcast(self):
    """
    Getter method for directed_broadcast, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network_forwarding/directed_broadcast (empty)

    YANG Description: Enable forwarding of directed broadcast
    """
    return self.__directed_broadcast
      
  def _set_directed_broadcast(self, v, load=False):
    """
    Setter method for directed_broadcast, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network_forwarding/directed_broadcast (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_directed_broadcast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_directed_broadcast() directly.

    YANG Description: Enable forwarding of directed broadcast
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="directed-broadcast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """directed_broadcast must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="directed-broadcast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='empty', is_config=True)""",
        })

    self.__directed_broadcast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_directed_broadcast(self):
    self.__directed_broadcast = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="directed-broadcast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='empty', is_config=True)


  def _get_unreachables(self):
    """
    Getter method for unreachables, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network_forwarding/unreachables (empty)

    YANG Description: Disable sending ICMP unreachables
    """
    return self.__unreachables
      
  def _set_unreachables(self, v, load=False):
    """
    Setter method for unreachables, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network_forwarding/unreachables (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unreachables is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unreachables() directly.

    YANG Description: Disable sending ICMP unreachables
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="unreachables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unreachables must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="unreachables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='empty', is_config=True)""",
        })

    self.__unreachables = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unreachables(self):
    self.__unreachables = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="unreachables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='empty', is_config=True)


  def _get_redirects(self):
    """
    Getter method for redirects, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network_forwarding/redirects (empty)

    YANG Description: Enable sending ICMP Redirect messages
    """
    return self.__redirects
      
  def _set_redirects(self, v, load=False):
    """
    Setter method for redirects, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network_forwarding/redirects (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_redirects is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_redirects() directly.

    YANG Description: Enable sending ICMP Redirect messages
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="redirects", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """redirects must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="redirects", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='empty', is_config=True)""",
        })

    self.__redirects = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_redirects(self):
    self.__redirects = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="redirects", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='empty', is_config=True)

  directed_broadcast = __builtin__.property(_get_directed_broadcast, _set_directed_broadcast)
  unreachables = __builtin__.property(_get_unreachables, _set_unreachables)
  redirects = __builtin__.property(_get_redirects, _set_redirects)


  _pyangbind_elements = OrderedDict([('directed_broadcast', directed_broadcast), ('unreachables', unreachables), ('redirects', redirects), ])


class yc_interface_configuration_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-ifmgr-cfg - based on the path /interface-configurations/interface-configuration. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The configuration for an interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__dampening','__mtus','__encapsulation','__shutdown','__interface_virtual','__secondary_admin_state','__interface_mode_non_physical','__bandwidth','__link_status','__description','__active','__interface_name','__ipv4_network','__ipv4_network_forwarding',)

  _yang_name = 'interface-configuration'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__dampening = YANGDynClass(base=yc_dampening_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_dampening, is_container='container', yang_name="dampening", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)
    self.__mtus = YANGDynClass(base=yc_mtus_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_mtus, is_container='container', yang_name="mtus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)
    self.__encapsulation = YANGDynClass(base=yc_encapsulation_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_encapsulation, is_container='container', yang_name="encapsulation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)
    self.__shutdown = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="shutdown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='empty', is_config=True)
    self.__interface_virtual = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="interface-virtual", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='empty', is_config=True)
    self.__secondary_admin_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 0}, 'maintenance': {'value': 1}},), is_leaf=True, yang_name="secondary-admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='Secondary-admin-state-enum', is_config=True)
    self.__interface_mode_non_physical = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {'value': 0}, 'point-to-point': {'value': 1}, 'multipoint': {'value': 2}, 'l2-transport': {'value': 3}},), default=six.text_type("default"), is_leaf=True, yang_name="interface-mode-non-physical", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='Interface-mode-enum', is_config=True)
    self.__bandwidth = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)
    self.__link_status = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="link-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='empty', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='string', is_config=True)
    self.__active = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(act)|(pre)'}), is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='Interface-active', is_config=True)
    self.__interface_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z0-9._/-]+'}), is_leaf=True, yang_name="interface-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='xr:Interface-name', is_config=True)
    self.__ipv4_network = YANGDynClass(base=yc_ipv4_network_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network, is_container='container', yang_name="ipv4-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)
    self.__ipv4_network_forwarding = YANGDynClass(base=yc_ipv4_network_forwarding_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_forwarding, is_container='container', yang_name="ipv4-network-forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interface-configurations', 'interface-configuration']

  def _get_dampening(self):
    """
    Getter method for dampening, mapped from YANG variable /interface_configurations/interface_configuration/dampening (container)

    YANG Description: Whether this interface's state changes are
dampened or not
    """
    return self.__dampening
      
  def _set_dampening(self, v, load=False):
    """
    Setter method for dampening, mapped from YANG variable /interface_configurations/interface_configuration/dampening (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dampening is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dampening() directly.

    YANG Description: Whether this interface's state changes are
dampened or not
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_dampening_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_dampening, is_container='container', yang_name="dampening", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dampening must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_dampening_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_dampening, is_container='container', yang_name="dampening", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)""",
        })

    self.__dampening = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dampening(self):
    self.__dampening = YANGDynClass(base=yc_dampening_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_dampening, is_container='container', yang_name="dampening", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)


  def _get_mtus(self):
    """
    Getter method for mtus, mapped from YANG variable /interface_configurations/interface_configuration/mtus (container)

    YANG Description: The MTU configuration for the interface
    """
    return self.__mtus
      
  def _set_mtus(self, v, load=False):
    """
    Setter method for mtus, mapped from YANG variable /interface_configurations/interface_configuration/mtus (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtus is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtus() directly.

    YANG Description: The MTU configuration for the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_mtus_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_mtus, is_container='container', yang_name="mtus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtus must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_mtus_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_mtus, is_container='container', yang_name="mtus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)""",
        })

    self.__mtus = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtus(self):
    self.__mtus = YANGDynClass(base=yc_mtus_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_mtus, is_container='container', yang_name="mtus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)


  def _get_encapsulation(self):
    """
    Getter method for encapsulation, mapped from YANG variable /interface_configurations/interface_configuration/encapsulation (container)

    YANG Description: The encapsulation on the interface
    """
    return self.__encapsulation
      
  def _set_encapsulation(self, v, load=False):
    """
    Setter method for encapsulation, mapped from YANG variable /interface_configurations/interface_configuration/encapsulation (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_encapsulation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_encapsulation() directly.

    YANG Description: The encapsulation on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_encapsulation_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_encapsulation, is_container='container', yang_name="encapsulation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """encapsulation must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_encapsulation_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_encapsulation, is_container='container', yang_name="encapsulation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)""",
        })

    self.__encapsulation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_encapsulation(self):
    self.__encapsulation = YANGDynClass(base=yc_encapsulation_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_encapsulation, is_container='container', yang_name="encapsulation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)


  def _get_shutdown(self):
    """
    Getter method for shutdown, mapped from YANG variable /interface_configurations/interface_configuration/shutdown (empty)

    YANG Description: The existence of this configuration indicates
the interface is shut down
    """
    return self.__shutdown
      
  def _set_shutdown(self, v, load=False):
    """
    Setter method for shutdown, mapped from YANG variable /interface_configurations/interface_configuration/shutdown (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shutdown is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shutdown() directly.

    YANG Description: The existence of this configuration indicates
the interface is shut down
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="shutdown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shutdown must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="shutdown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='empty', is_config=True)""",
        })

    self.__shutdown = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shutdown(self):
    self.__shutdown = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="shutdown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='empty', is_config=True)


  def _get_interface_virtual(self):
    """
    Getter method for interface_virtual, mapped from YANG variable /interface_configurations/interface_configuration/interface_virtual (empty)

    YANG Description: The mode in which an interface is running. The
existence of this object causes the creation of
the software virtual/subinterface.
    """
    return self.__interface_virtual
      
  def _set_interface_virtual(self, v, load=False):
    """
    Setter method for interface_virtual, mapped from YANG variable /interface_configurations/interface_configuration/interface_virtual (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_virtual is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_virtual() directly.

    YANG Description: The mode in which an interface is running. The
existence of this object causes the creation of
the software virtual/subinterface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="interface-virtual", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_virtual must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="interface-virtual", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='empty', is_config=True)""",
        })

    self.__interface_virtual = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_virtual(self):
    self.__interface_virtual = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="interface-virtual", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='empty', is_config=True)


  def _get_secondary_admin_state(self):
    """
    Getter method for secondary_admin_state, mapped from YANG variable /interface_configurations/interface_configuration/secondary_admin_state (Secondary-admin-state-enum)

    YANG Description: The secondary admin state of the interface
    """
    return self.__secondary_admin_state
      
  def _set_secondary_admin_state(self, v, load=False):
    """
    Setter method for secondary_admin_state, mapped from YANG variable /interface_configurations/interface_configuration/secondary_admin_state (Secondary-admin-state-enum)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_secondary_admin_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_secondary_admin_state() directly.

    YANG Description: The secondary admin state of the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 0}, 'maintenance': {'value': 1}},), is_leaf=True, yang_name="secondary-admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='Secondary-admin-state-enum', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """secondary_admin_state must be of a type compatible with Secondary-admin-state-enum""",
          'defined-type': "Cisco-IOS-XR-ifmgr-cfg:Secondary-admin-state-enum",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 0}, 'maintenance': {'value': 1}},), is_leaf=True, yang_name="secondary-admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='Secondary-admin-state-enum', is_config=True)""",
        })

    self.__secondary_admin_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_secondary_admin_state(self):
    self.__secondary_admin_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 0}, 'maintenance': {'value': 1}},), is_leaf=True, yang_name="secondary-admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='Secondary-admin-state-enum', is_config=True)


  def _get_interface_mode_non_physical(self):
    """
    Getter method for interface_mode_non_physical, mapped from YANG variable /interface_configurations/interface_configuration/interface_mode_non_physical (Interface-mode-enum)

    YANG Description: The mode in which an interface is running. The
existence of this object causes the creation of
the software subinterface.
    """
    return self.__interface_mode_non_physical
      
  def _set_interface_mode_non_physical(self, v, load=False):
    """
    Setter method for interface_mode_non_physical, mapped from YANG variable /interface_configurations/interface_configuration/interface_mode_non_physical (Interface-mode-enum)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_mode_non_physical is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_mode_non_physical() directly.

    YANG Description: The mode in which an interface is running. The
existence of this object causes the creation of
the software subinterface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {'value': 0}, 'point-to-point': {'value': 1}, 'multipoint': {'value': 2}, 'l2-transport': {'value': 3}},), default=six.text_type("default"), is_leaf=True, yang_name="interface-mode-non-physical", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='Interface-mode-enum', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_mode_non_physical must be of a type compatible with Interface-mode-enum""",
          'defined-type': "Cisco-IOS-XR-ifmgr-cfg:Interface-mode-enum",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {'value': 0}, 'point-to-point': {'value': 1}, 'multipoint': {'value': 2}, 'l2-transport': {'value': 3}},), default=six.text_type("default"), is_leaf=True, yang_name="interface-mode-non-physical", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='Interface-mode-enum', is_config=True)""",
        })

    self.__interface_mode_non_physical = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_mode_non_physical(self):
    self.__interface_mode_non_physical = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {'value': 0}, 'point-to-point': {'value': 1}, 'multipoint': {'value': 2}, 'l2-transport': {'value': 3}},), default=six.text_type("default"), is_leaf=True, yang_name="interface-mode-non-physical", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='Interface-mode-enum', is_config=True)


  def _get_bandwidth(self):
    """
    Getter method for bandwidth, mapped from YANG variable /interface_configurations/interface_configuration/bandwidth (uint32)

    YANG Description: The bandwidth of the interface in kbps
    """
    return self.__bandwidth
      
  def _set_bandwidth(self, v, load=False):
    """
    Setter method for bandwidth, mapped from YANG variable /interface_configurations/interface_configuration/bandwidth (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bandwidth() directly.

    YANG Description: The bandwidth of the interface in kbps
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bandwidth must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bandwidth(self):
    self.__bandwidth = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)


  def _get_link_status(self):
    """
    Getter method for link_status, mapped from YANG variable /interface_configurations/interface_configuration/link_status (empty)

    YANG Description: Enable interface and line-protocol state change
alarms
    """
    return self.__link_status
      
  def _set_link_status(self, v, load=False):
    """
    Setter method for link_status, mapped from YANG variable /interface_configurations/interface_configuration/link_status (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_status() directly.

    YANG Description: Enable interface and line-protocol state change
alarms
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="link-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_status must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="link-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='empty', is_config=True)""",
        })

    self.__link_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_status(self):
    self.__link_status = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="link-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='empty', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /interface_configurations/interface_configuration/description (string)

    YANG Description: The description of this interface
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /interface_configurations/interface_configuration/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: The description of this interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='string', is_config=True)


  def _get_active(self):
    """
    Getter method for active, mapped from YANG variable /interface_configurations/interface_configuration/active (Interface-active)

    YANG Description: Whether the interface is active or
preconfigured
    """
    return self.__active
      
  def _set_active(self, v, load=False):
    """
    Setter method for active, mapped from YANG variable /interface_configurations/interface_configuration/active (Interface-active)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_active is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_active() directly.

    YANG Description: Whether the interface is active or
preconfigured
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(act)|(pre)'}), is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='Interface-active', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """active must be of a type compatible with Interface-active""",
          'defined-type': "Cisco-IOS-XR-ifmgr-cfg:Interface-active",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(act)|(pre)'}), is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='Interface-active', is_config=True)""",
        })

    self.__active = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_active(self):
    self.__active = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(act)|(pre)'}), is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='Interface-active', is_config=True)


  def _get_interface_name(self):
    """
    Getter method for interface_name, mapped from YANG variable /interface_configurations/interface_configuration/interface_name (xr:Interface-name)

    YANG Description: The name of the interface
    """
    return self.__interface_name
      
  def _set_interface_name(self, v, load=False):
    """
    Setter method for interface_name, mapped from YANG variable /interface_configurations/interface_configuration/interface_name (xr:Interface-name)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_name() directly.

    YANG Description: The name of the interface
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z0-9._/-]+'}), is_leaf=True, yang_name="interface-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='xr:Interface-name', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_name must be of a type compatible with xr:Interface-name""",
          'defined-type': "xr:Interface-name",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z0-9._/-]+'}), is_leaf=True, yang_name="interface-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='xr:Interface-name', is_config=True)""",
        })

    self.__interface_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_name(self):
    self.__interface_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z0-9._/-]+'}), is_leaf=True, yang_name="interface-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='xr:Interface-name', is_config=True)


  def _get_ipv4_network(self):
    """
    Getter method for ipv4_network, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network (container)

    YANG Description: Interface IPv4 Network configuration data
    """
    return self.__ipv4_network
      
  def _set_ipv4_network(self, v, load=False):
    """
    Setter method for ipv4_network, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_network() directly.

    YANG Description: Interface IPv4 Network configuration data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv4_network_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network, is_container='container', yang_name="ipv4-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_network must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv4_network_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network, is_container='container', yang_name="ipv4-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)""",
        })

    self.__ipv4_network = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_network(self):
    self.__ipv4_network = YANGDynClass(base=yc_ipv4_network_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network, is_container='container', yang_name="ipv4-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)


  def _get_ipv4_network_forwarding(self):
    """
    Getter method for ipv4_network_forwarding, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network_forwarding (container)

    YANG Description: Interface IPv4 Network configuration data also
used for forwarding
    """
    return self.__ipv4_network_forwarding
      
  def _set_ipv4_network_forwarding(self, v, load=False):
    """
    Setter method for ipv4_network_forwarding, mapped from YANG variable /interface_configurations/interface_configuration/ipv4_network_forwarding (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_network_forwarding is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_network_forwarding() directly.

    YANG Description: Interface IPv4 Network configuration data also
used for forwarding
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv4_network_forwarding_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_forwarding, is_container='container', yang_name="ipv4-network-forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_network_forwarding must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv4_network_forwarding_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_forwarding, is_container='container', yang_name="ipv4-network-forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)""",
        })

    self.__ipv4_network_forwarding = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_network_forwarding(self):
    self.__ipv4_network_forwarding = YANGDynClass(base=yc_ipv4_network_forwarding_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_ipv4_network_forwarding, is_container='container', yang_name="ipv4-network-forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ipv4-io-cfg', defining_module='Cisco-IOS-XR-ipv4-io-cfg', yang_type='container', is_config=True)

  dampening = __builtin__.property(_get_dampening, _set_dampening)
  mtus = __builtin__.property(_get_mtus, _set_mtus)
  encapsulation = __builtin__.property(_get_encapsulation, _set_encapsulation)
  shutdown = __builtin__.property(_get_shutdown, _set_shutdown)
  interface_virtual = __builtin__.property(_get_interface_virtual, _set_interface_virtual)
  secondary_admin_state = __builtin__.property(_get_secondary_admin_state, _set_secondary_admin_state)
  interface_mode_non_physical = __builtin__.property(_get_interface_mode_non_physical, _set_interface_mode_non_physical)
  bandwidth = __builtin__.property(_get_bandwidth, _set_bandwidth)
  link_status = __builtin__.property(_get_link_status, _set_link_status)
  description = __builtin__.property(_get_description, _set_description)
  active = __builtin__.property(_get_active, _set_active)
  interface_name = __builtin__.property(_get_interface_name, _set_interface_name)
  ipv4_network = __builtin__.property(_get_ipv4_network, _set_ipv4_network)
  ipv4_network_forwarding = __builtin__.property(_get_ipv4_network_forwarding, _set_ipv4_network_forwarding)


  _pyangbind_elements = OrderedDict([('dampening', dampening), ('mtus', mtus), ('encapsulation', encapsulation), ('shutdown', shutdown), ('interface_virtual', interface_virtual), ('secondary_admin_state', secondary_admin_state), ('interface_mode_non_physical', interface_mode_non_physical), ('bandwidth', bandwidth), ('link_status', link_status), ('description', description), ('active', active), ('interface_name', interface_name), ('ipv4_network', ipv4_network), ('ipv4_network_forwarding', ipv4_network_forwarding), ])


class yc_interface_configurations_Cisco_IOS_XR_ifmgr_cfg__interface_configurations(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-ifmgr-cfg - based on the path /interface-configurations. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: interface configurations
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface_configuration',)

  _yang_name = 'interface-configurations'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface_configuration = YANGDynClass(base=YANGListType("active interface_name",yc_interface_configuration_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration, yang_name="interface-configuration", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='active interface-name', extensions=None), is_container='list', yang_name="interface-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interface-configurations']

  def _get_interface_configuration(self):
    """
    Getter method for interface_configuration, mapped from YANG variable /interface_configurations/interface_configuration (list)

    YANG Description: The configuration for an interface
    """
    return self.__interface_configuration
      
  def _set_interface_configuration(self, v, load=False):
    """
    Setter method for interface_configuration, mapped from YANG variable /interface_configurations/interface_configuration (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_configuration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_configuration() directly.

    YANG Description: The configuration for an interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("active interface_name",yc_interface_configuration_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration, yang_name="interface-configuration", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='active interface-name', extensions=None), is_container='list', yang_name="interface-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_configuration must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("active interface_name",yc_interface_configuration_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration, yang_name="interface-configuration", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='active interface-name', extensions=None), is_container='list', yang_name="interface-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='list', is_config=True)""",
        })

    self.__interface_configuration = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_configuration(self):
    self.__interface_configuration = YANGDynClass(base=YANGListType("active interface_name",yc_interface_configuration_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration, yang_name="interface-configuration", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='active interface-name', extensions=None), is_container='list', yang_name="interface-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='list', is_config=True)

  interface_configuration = __builtin__.property(_get_interface_configuration, _set_interface_configuration)


  _pyangbind_elements = OrderedDict([('interface_configuration', interface_configuration), ])


class Cisco_IOS_XR_ifmgr_cfg(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-ifmgr-cfg - based on the path /Cisco-IOS-XR-ifmgr-cfg. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains a collection of YANG definitions
for Cisco IOS-XR ifmgr package configuration.

This module contains definitions
for the following management objects:
  global-interface-configuration: Global scoped configuration
    for interfaces
  interface-configurations: interface configurations

Copyright (c) 2013-2018 by Cisco Systems, Inc.
All rights reserved.
  """
  __slots__ = ('_path_helper', '_extmethods', '__global_interface_configuration','__interface_configurations',)

  _yang_name = 'Cisco-IOS-XR-ifmgr-cfg'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__global_interface_configuration = YANGDynClass(base=yc_global_interface_configuration_Cisco_IOS_XR_ifmgr_cfg__global_interface_configuration, is_container='container', yang_name="global-interface-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)
    self.__interface_configurations = YANGDynClass(base=yc_interface_configurations_Cisco_IOS_XR_ifmgr_cfg__interface_configurations, is_container='container', yang_name="interface-configurations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_global_interface_configuration(self):
    """
    Getter method for global_interface_configuration, mapped from YANG variable /global_interface_configuration (container)

    YANG Description: Global scoped configuration for interfaces
    """
    return self.__global_interface_configuration
      
  def _set_global_interface_configuration(self, v, load=False):
    """
    Setter method for global_interface_configuration, mapped from YANG variable /global_interface_configuration (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_global_interface_configuration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_global_interface_configuration() directly.

    YANG Description: Global scoped configuration for interfaces
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_global_interface_configuration_Cisco_IOS_XR_ifmgr_cfg__global_interface_configuration, is_container='container', yang_name="global-interface-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """global_interface_configuration must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_global_interface_configuration_Cisco_IOS_XR_ifmgr_cfg__global_interface_configuration, is_container='container', yang_name="global-interface-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)""",
        })

    self.__global_interface_configuration = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_global_interface_configuration(self):
    self.__global_interface_configuration = YANGDynClass(base=yc_global_interface_configuration_Cisco_IOS_XR_ifmgr_cfg__global_interface_configuration, is_container='container', yang_name="global-interface-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)


  def _get_interface_configurations(self):
    """
    Getter method for interface_configurations, mapped from YANG variable /interface_configurations (container)

    YANG Description: interface configurations
    """
    return self.__interface_configurations
      
  def _set_interface_configurations(self, v, load=False):
    """
    Setter method for interface_configurations, mapped from YANG variable /interface_configurations (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_configurations is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_configurations() directly.

    YANG Description: interface configurations
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_interface_configurations_Cisco_IOS_XR_ifmgr_cfg__interface_configurations, is_container='container', yang_name="interface-configurations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_configurations must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_interface_configurations_Cisco_IOS_XR_ifmgr_cfg__interface_configurations, is_container='container', yang_name="interface-configurations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)""",
        })

    self.__interface_configurations = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_configurations(self):
    self.__interface_configurations = YANGDynClass(base=yc_interface_configurations_Cisco_IOS_XR_ifmgr_cfg__interface_configurations, is_container='container', yang_name="interface-configurations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)

  global_interface_configuration = __builtin__.property(_get_global_interface_configuration, _set_global_interface_configuration)
  interface_configurations = __builtin__.property(_get_interface_configurations, _set_interface_configurations)


  _pyangbind_elements = OrderedDict([('global_interface_configuration', global_interface_configuration), ('interface_configurations', interface_configurations), ])


class Cisco_IOS_XR_ipv4_io_cfg(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-ipv4-io-cfg - based on the path /Cisco-IOS-XR-ipv4-io-cfg. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains a collection of YANG definitions
for Cisco IOS-XR ipv4-io package configuration.

This YANG module augments the
  Cisco-IOS-XR-ifmgr-cfg
module with configuration data.

Copyright (c) 2013-2018 by Cisco Systems, Inc.
All rights reserved.
  """
  _pyangbind_elements = {}

  

class Cisco_IOS_XR_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-types - based on the path /Cisco-IOS-XR-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains a collection of IOS-XR derived YANG data
types.

Copyright (c) 2013-2018 by Cisco Systems, Inc.
All rights reserved.
  """
  _pyangbind_elements = {}

  

class ietf_inet_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-inet-types - based on the path /ietf-inet-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains a collection of generally useful derived
YANG data types for Internet addresses and related things.

Copyright (c) 2013 IETF Trust and the persons identified as
authors of the code.  All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject
to the license terms contained in, the Simplified BSD License
set forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(http://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC 6991; see
the RFC itself for full legal notices.
  """
  _pyangbind_elements = {}

  

